diff --git a/bindings/IDLExtendedAttributes.txt b/bindings/IDLExtendedAttributes.txt
index 3bb46683..c0215051 100644
--- a/bindings/IDLExtendedAttributes.txt
+++ b/bindings/IDLExtendedAttributes.txt
@@ -37,7 +37,7 @@ CEReactions
 CachedAccessor
 CachedAttribute=*
 CallWith=ExecutionContext|ScriptState|ScriptArguments|CurrentWindow|EnteredWindow|ThisValue
-CheckSecurity=Receiver|ReturnValue
+CheckSecurity=Receiver|ReturnValue|Caller|WriteSelf|Creation
 Clamp
 Constructor
 # FIXME: remove [ConstructorCallWith=Document], as can instead use
diff --git a/bindings/bindings.gni b/bindings/bindings.gni
index 1e41cd00..9fb45433 100644
--- a/bindings/bindings.gni
+++ b/bindings/bindings.gni
@@ -66,6 +66,8 @@ bindings_core_v8_files =
                     "core/v8/RetainedObjectInfo.h",
                     "core/v8/ScheduledAction.cpp",
                     "core/v8/ScheduledAction.h",
+                    "core/v8/ScriptCallStackFactory.cpp",
+                    "core/v8/ScriptCallStackFactory.h",
                     "core/v8/ScriptController.cpp",
                     "core/v8/ScriptController.h",
                     "core/v8/ScriptCustomElementDefinition.cpp",
diff --git a/bindings/core/v8/BindingSecurity.cpp b/bindings/core/v8/BindingSecurity.cpp
index 47998b48..593f9d4e 100644
--- a/bindings/core/v8/BindingSecurity.cpp
+++ b/bindings/core/v8/BindingSecurity.cpp
@@ -46,6 +46,15 @@
 #include "platform/bindings/WrapperCreationSecurityCheck.h"
 #include "platform/weborigin/SecurityOrigin.h"
 
+// Observer
+#include "base/logging.h"
+#include "core/dom/Observer.h"
+#include "core/dom/NodeList.h"
+#include "bindings/core/v8/ScriptCallStackFactory.h"
+#include "core/html/HTMLAnchorElement.h"
+#include "core/html/HTMLScriptElement.h"
+
+
 namespace blink {
 
 namespace {
@@ -392,4 +401,206 @@ void BindingSecurity::FailedAccessCheckFor(v8::Isolate* isolate,
       target->CrossDomainAccessErrorMessage(CurrentDOMWindow(isolate)));
 }
 
+
+void BindingSecurity::LogAccessToElement(
+    const LocalDOMWindow* accessing_window,
+    EventTarget* target,
+    DOMAccessRequest accessRequest,
+    const String& memberName,
+    ExceptionState& exception_state,
+    const String& argument) {
+  if (IsObserverEnabled() && target) {
+    Node* node = target->ToNode();
+    if (node) {
+      LogAccessToElement(accessing_window, node, accessRequest,
+                                        memberName, exception_state, argument);
+    }
+  }
+  return;
+}
+
+void BindingSecurity::LogAccessToElement(
+    const LocalDOMWindow* accessing_window,
+    Node* target,
+    DOMAccessRequest accessRequest,
+    const String& memberName,
+    ExceptionState& exception_state,
+    const String& argument) {
+  if (IsObserverEnabled() && target) {
+    v8::Local<v8::StackFrame> frame = getBottomFrame(maxCallStackSizeToCapture);
+    if ((target->IsElementNode() || target->IsDocumentNode())) {
+      LogAccessToElement(accessing_window, target, accessRequest,
+                                      memberName, frame, argument);
+    }
+  }
+  return;
+}
+
+void BindingSecurity::LogAccessToElement(
+    const LocalDOMWindow* accessing_window,
+    Node* target,
+    DOMAccessRequest accessRequest,
+    const String& memberName,
+    const String& argument) {
+  if (IsObserverEnabled() && target) {
+    if (target->IsPseudoElement())
+      return;
+    v8::Local<v8::StackFrame> frame = getBottomFrame(maxCallStackSizeToCapture);
+    if ((target->IsElementNode() || target->IsDocumentNode())) {
+      LogAccessToElement(accessing_window, target, accessRequest,
+                                      memberName, frame, argument);
+    }
+  }
+  return;
+}
+
+void BindingSecurity::LogAccessToElement(
+    const LocalDOMWindow* accessing_window,
+    Node* target,
+    DOMAccessRequest accessRequest,
+    const String& memberName,
+    const v8::Local<v8::StackFrame>& frame, 
+    const String& argument) {
+  if (IsObserverEnabled() && target) {
+    if (target->IsPseudoElement())
+      return;
+    if(!(IsHTMLAnchorElement(target) || IsHTMLScriptElement(target)))
+      return;
+
+    if (target->IsElementNode() || target->IsDocumentNode()) {
+      Document &document = target->GetDocument();
+      int accessID = target->GetDocument().accessCount();
+      String log = "{\"info\" :\"";
+      log.append(String::Number(accessID));
+      log.append(":");
+      log.append(String::Number(target->IsInTreeScope()));
+      log.append(":");
+      log.append(String::Number(accessRequest));
+      log.append(":");
+      log.append(memberName);
+      log.append("\"");
+
+      String stack = "";
+
+      String frameSourceURL = toCoreStringOrDefault(frame->GetScriptNameOrSourceURL(),
+          "<anonymous>");
+      const KURL callerSourceURL = KURL(frameSourceURL);
+      if (!IsChromeURL(callerSourceURL.Protocol()) && !IsExtensionURL(callerSourceURL.Protocol())) {
+        int scriptID = frame->GetScriptId();
+        document.setScriptID2URL(scriptID, frameSourceURL);
+        stack.append(String::Number(scriptID));
+      }
+
+      unsigned stack_length = stack.length();
+      if (stack_length > 0) {
+        log.append(", \"stack\": ");
+        log.append(JSONValue::QuoteString(stack));
+      }
+
+      log.append(argument);
+      log.append("}");
+      log = JSONValue::QuoteString(log);
+
+      if(IsHTMLAnchorElement(target))
+        ToHTMLAnchorElement(target)->appendObserverLog(log);
+      else // html script element
+        ToHTMLScriptElement(target)->appendObserverLog(log);
+    }
+  }
+  return;
+}
+
+void BindingSecurity::SetNodeAndChildrenInitiator(
+    Document* document,
+    Node* node,
+    bool setChildren) {
+  if (IsObserverEnabled() && node) {
+    if (node->IsPseudoElement())
+      return;
+
+    v8::Local<v8::StackFrame> frame = getBottomFrame(maxCallStackSizeToCapture);
+    String initiator = "";
+    
+    String frameSourceURL = toCoreStringOrDefault(frame->GetScriptNameOrSourceURL(),
+        "<anonymous>");
+    const KURL callerSourceURL = KURL(frameSourceURL);
+    if (!IsChromeURL(callerSourceURL.Protocol()) && !IsExtensionURL(callerSourceURL.Protocol())) {
+      int scriptID = frame->GetScriptId();
+      document->setScriptID2URL(scriptID, frameSourceURL);
+      initiator.append(String::Number(scriptID));
+    }
+    if (setChildren) {
+      if(IsHTMLAnchorElement(node))
+        ToHTMLAnchorElement(node)->setChildrenInitiator(initiator);
+      else if(IsHTMLScriptElement(node))
+        ToHTMLScriptElement(node)->setChildrenInitiator(initiator);
+      else {
+        NodeList* children = node->childNodes();
+        int length = children->length();
+        for (int j = 0; j < length; ++j) {
+          Node* child = children->item(j);
+          if (child->IsElementNode()) {
+            if(IsHTMLAnchorElement(child))
+              ToHTMLAnchorElement(child)->setChildrenInitiator(initiator);
+            else if(IsHTMLScriptElement(child))
+              ToHTMLScriptElement(child)->setChildrenInitiator(initiator);
+          }
+        }
+      }
+    }
+    else {
+      if(IsHTMLAnchorElement(node))
+        ToHTMLAnchorElement(node)->setInitiator(initiator);
+      else if(IsHTMLScriptElement(node))
+        ToHTMLScriptElement(node)->setInitiator(initiator);
+    }
+  }
+}
+
+void BindingSecurity::LogAPIAccess(Document* document, const String& api, const String& url) {
+  int nid = document->getCurrentEventTarget();
+
+  v8::Local<v8::StackFrame> frame = getBottomFrame(maxCallStackSizeToCapture);
+  
+  String log = "{\"nid\": ";
+  log.append(String::Number(nid));
+  log.append(", \"type\": \"");
+  log.append(document->getCurrentEventType());
+  log.append("\", \"API\": \"");
+  log.append(api);
+  log.append("\", \"url\": ");
+  log.append(JSONValue::QuoteString(url));
+  if (nid >= 0) {
+    String stack = "";
+    
+    String frameSourceURL = toCoreStringOrDefault(frame->GetScriptNameOrSourceURL(),
+        "<anonymous>");
+    const KURL callerSourceURL = KURL(frameSourceURL);
+    if (!IsChromeURL(callerSourceURL.Protocol()) && !IsExtensionURL(callerSourceURL.Protocol())) {
+      int scriptID = frame->GetScriptId();
+      document->setScriptID2URL(scriptID, frameSourceURL);
+      stack.append(String::Number(scriptID));
+    }
+    unsigned stack_length = stack.length();
+    if (stack_length > 0) {
+      log.append(", \"stack\": ");
+      log.append(JSONValue::QuoteString(stack));
+    }
+  }
+  log.append("}");
+  document->appendAPILog(log);
+}
+
+bool BindingSecurity::IsChromeURL(const String& protocol) {
+  if (protocol.IsEmpty() || protocol == "chrome" ||
+      protocol == "chrome-devtools" || protocol == "chrome-search") {
+    return true;
+  }
+  return false;
+}
+
+bool BindingSecurity::IsExtensionURL(const String& protocol) {
+    return protocol == "chrome-extension";
+}
+
 }  // namespace blink
diff --git a/bindings/core/v8/BindingSecurity.h b/bindings/core/v8/BindingSecurity.h
index ca383ffb..efa3c81c 100644
--- a/bindings/core/v8/BindingSecurity.h
+++ b/bindings/core/v8/BindingSecurity.h
@@ -35,6 +35,9 @@
 #include "platform/wtf/Allocator.h"
 #include "v8/include/v8.h"
 
+// Observer
+#include "core/dom/Observer.h"
+
 namespace blink {
 
 class DOMWindow;
@@ -44,6 +47,7 @@ class LocalDOMWindow;
 class Location;
 class Node;
 struct WrapperTypeInfo;
+class Document;
 
 class CORE_EXPORT BindingSecurity {
   STATIC_ONLY(BindingSecurity);
@@ -126,6 +130,39 @@ class CORE_EXPORT BindingSecurity {
 
   static void InitWrapperCreationSecurityCheck();
 
+  // Log the caller (|accessingScript|)'s access to the DOM element (|target).
+  static void LogAccessToElement(const LocalDOMWindow* accessing_window,
+                                         EventTarget* target,
+                                         DOMAccessRequest accessRequest,
+                                         const String&,
+                                         ExceptionState&,
+                                         const String& argument = "");
+  static void LogAccessToElement(const LocalDOMWindow* accessing_window,
+                                         Node* target,
+                                         DOMAccessRequest accessRequest,
+                                         const String&,
+                                         ExceptionState&,
+                                         const String& argument = "");
+  static void LogAccessToElement(const LocalDOMWindow* accessing_window,
+                                         Node* target,
+                                         DOMAccessRequest accessRequest,
+                                         const String&,
+                                         const String& argument = "");
+  static void LogAccessToElement(const LocalDOMWindow* accessing_window,
+                                         Node* target,
+                                         DOMAccessRequest accessRequest,
+                                         const String&,
+                                         const v8::Local<v8::StackFrame>&, 
+                                         const String& argument = "");
+  static void SetNodeAndChildrenInitiator(Document* document,
+                              Node* node,
+                              bool setChildren = false);
+  static void LogAPIAccess(Document* document,
+                                       const String& api,
+                                       const String& url);
+  static bool IsChromeURL(const String&);
+  static bool IsExtensionURL(const String&);
+
  private:
   // Returns true if |accessingWindow| is allowed named access to |targetWindow|
   // because they're the same origin.  Note that named access should be allowed
diff --git a/bindings/core/v8/ScriptCallStackFactory.cpp b/bindings/core/v8/ScriptCallStackFactory.cpp
new file mode 100644
index 00000000..ef0f665e
--- /dev/null
+++ b/bindings/core/v8/ScriptCallStackFactory.cpp
@@ -0,0 +1,97 @@
+/*
+ * Copyright (c) 2010 Google Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer
+ * in the documentation and/or other materials provided with the
+ * distribution.
+ *     * Neither the name of Google Inc. nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "bindings/core/v8/ScriptCallStackFactory.h"
+#include "platform/bindings/V8Binding.h"
+#include "platform/wtf/text/WTFString.h"
+
+#include <v8-debug.h>
+
+namespace blink {
+
+v8::Local<v8::StackTrace> captureCurrentStackTrace(size_t maxStackSize)
+{
+    v8::Isolate* isolate = v8::Isolate::GetCurrent();
+    if (!isolate->InContext())
+      return v8::Local<v8::StackTrace>();
+    v8::EscapableHandleScope handleScope(isolate);
+    v8::Local<v8::StackTrace> stackTrace =
+        v8::StackTrace::CurrentStackTrace(isolate, maxStackSize, stackTraceOptions);
+    return handleScope.Escape(stackTrace);
+}
+
+v8::Local<v8::StackFrame> getTopFrame()
+{
+    v8::Isolate* isolate=v8::Isolate::GetCurrent();
+    v8::EscapableHandleScope handleScope(isolate);
+    v8::Local<v8::StackTrace> stackTrace = captureCurrentStackTrace(1);
+    if (stackTrace.IsEmpty() || stackTrace->GetFrameCount() <= 0)
+      return v8::Local<v8::StackFrame>();
+    return handleScope.Escape(stackTrace->GetFrame(0));
+}
+
+v8::Local<v8::StackFrame> getTopFrame(size_t maxStackSize)
+{
+    v8::Isolate* isolate = v8::Isolate::GetCurrent();
+    if (!isolate->InContext())
+      return v8::Local<v8::StackFrame>();
+    v8::EscapableHandleScope handleScope(isolate);
+    v8::Local<v8::StackTrace> stackTrace =
+        v8::StackTrace::TopFrameStackTrace(isolate, maxStackSize, stackTraceOptions);
+    if (stackTrace.IsEmpty() || stackTrace->GetFrameCount() <= 0)
+      return v8::Local<v8::StackFrame>();
+    int index = 0;
+    return handleScope.Escape(stackTrace->GetFrame(index));
+}
+
+v8::Local<v8::StackFrame> getBottomFrame(size_t maxStackSize)
+{
+    v8::Isolate* isolate = v8::Isolate::GetCurrent();
+    if (!isolate->InContext())
+      return v8::Local<v8::StackFrame>();
+    v8::EscapableHandleScope handleScope(isolate);
+    v8::Local<v8::StackTrace> stackTrace =
+        v8::StackTrace::BottomFrameStackTrace(isolate, maxStackSize, stackTraceOptions);
+    if (stackTrace.IsEmpty() || stackTrace->GetFrameCount() <= 0)
+      return v8::Local<v8::StackFrame>();
+    int index = stackTrace->GetFrameCount() - 1;
+    return handleScope.Escape(stackTrace->GetFrame(index));
+}
+
+String toCoreStringOrDefault(const v8::Local<v8::String>& v8_string,
+    const String& dflt)
+{
+  if (v8_string.IsEmpty())
+    return dflt;
+  return ToCoreString(v8_string);
+}
+
+} // namespace blink
diff --git a/bindings/core/v8/ScriptCallStackFactory.h b/bindings/core/v8/ScriptCallStackFactory.h
new file mode 100644
index 00000000..04cd4528
--- /dev/null
+++ b/bindings/core/v8/ScriptCallStackFactory.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2010 Google Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer
+ * in the documentation and/or other materials provided with the
+ * distribution.
+ *     * Neither the name of Google Inc. nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef ScriptCallStackFactory_h
+#define ScriptCallStackFactory_h
+
+#include "platform/wtf/Forward.h"
+#include <v8.h>
+
+namespace blink {
+
+const v8::StackTrace::StackTraceOptions stackTraceOptions = static_cast<v8::StackTrace::StackTraceOptions>(
+      v8::StackTrace::kLineNumber
+    | v8::StackTrace::kColumnOffset
+    | v8::StackTrace::kScriptId
+    | v8::StackTrace::kScriptNameOrSourceURL
+    | v8::StackTrace::kFunctionName);
+
+static const size_t maxCallStackSizeToCapture = 200;
+
+v8::Local<v8::StackTrace> captureCurrentStackTrace(size_t maxStackSize);
+v8::Local<v8::StackFrame> getTopFrame();
+v8::Local<v8::StackFrame> getTopFrame(size_t maxStackSize);
+v8::Local<v8::StackFrame> getBottomFrame(size_t maxStackSize);
+
+String toCoreStringOrDefault(const v8::Local<v8::String>&, const String&);
+} // namespace blink
+
+#endif // ScriptCallStackFactory_h
diff --git a/bindings/core/v8/ScriptController.h b/bindings/core/v8/ScriptController.h
index e1f90d2b..63a9d80b 100644
--- a/bindings/core/v8/ScriptController.h
+++ b/bindings/core/v8/ScriptController.h
@@ -144,10 +144,15 @@ class CORE_EXPORT ScriptController final
   static void RegisterExtensionIfNeeded(v8::Extension*);
   static V8Extensions& RegisteredExtensions();
 
+  int scriptID() const { return script_id_; }
+  void setScriptID(int scriptID = -1) { script_id_ = scriptID; }
+
  private:
   ScriptController(LocalFrame& frame,
                    LocalWindowProxyManager& window_proxy_manager)
-      : frame_(&frame), window_proxy_manager_(&window_proxy_manager) {}
+      : frame_(&frame), window_proxy_manager_(&window_proxy_manager) {
+        script_id_ = -1;
+      }
 
   LocalFrame* GetFrame() const { return frame_; }
   v8::Isolate* GetIsolate() const {
@@ -162,6 +167,7 @@ class CORE_EXPORT ScriptController final
 
   const Member<LocalFrame> frame_;
   const Member<LocalWindowProxyManager> window_proxy_manager_;
+  int script_id_;
 };
 
 }  // namespace blink
diff --git a/bindings/core/v8/V8ScriptRunner.cpp b/bindings/core/v8/V8ScriptRunner.cpp
index 2668f610..5adc8c04 100644
--- a/bindings/core/v8/V8ScriptRunner.cpp
+++ b/bindings/core/v8/V8ScriptRunner.cpp
@@ -59,6 +59,10 @@
 #include <alloca.h>
 #endif
 
+// Observer
+#include "bindings/core/v8/BindingSecurity.h"
+#include "bindings/core/v8/ScriptController.h"
+
 namespace blink {
 
 namespace {
@@ -568,6 +572,13 @@ v8::MaybeLocal<v8::Value> V8ScriptRunner::RunCompiledScript(
                                          v8::MicrotasksScope::kRunMicrotasks);
     probe::ExecuteScript probe(context);
     result = script->Run(isolate->GetCurrentContext());
+    if (context->IsDocument()) {
+      String scriptName = *v8::String::Utf8Value(script->GetUnboundScript()->GetScriptName());
+      int scriptID = script->GetUnboundScript()->GetId();
+      ToDocument(context)->setScriptID2URL(scriptID, scriptName);
+      if (LocalFrame *localFrame = ToDocument(context)->GetFrame())
+        localFrame->GetScriptController().setScriptID(scriptID);
+    }
   }
 
   CHECK(!isolate->IsDead());
diff --git a/bindings/scripts/generate_v8_context_snapshot_external_references.py b/bindings/scripts/generate_v8_context_snapshot_external_references.py
index 1fa3fae3..2259a3ed 100644
--- a/bindings/scripts/generate_v8_context_snapshot_external_references.py
+++ b/bindings/scripts/generate_v8_context_snapshot_external_references.py
@@ -106,7 +106,9 @@ class InterfaceTemplateContextBuilder(object):
                 has_origin_safe_method_setter = is_global and any(
                     method['is_check_security_for_receiver'] and not method['is_unforgeable']
                     for method in methods)
-                has_security_check = ('CheckSecurity' in interface.extended_attributes and
+                has_security_check = (
+                    (v8_utilities.has_extended_attribute_value(interface, 'CheckSecurity', 'Receiver') or
+                    v8_utilities.has_extended_attribute_value(interface, 'CheckSecurity', 'ReturnValue')) and
                                       interface.name != 'EventTarget')
                 has_cross_origin_named_getter = (any(method['is_cross_origin'] for method in methods) or
                                                  any(attribute['has_cross_origin_getter'] for attribute in attributes))
diff --git a/bindings/scripts/v8_attributes.py b/bindings/scripts/v8_attributes.py
index fad2784a..f57919a0 100644
--- a/bindings/scripts/v8_attributes.py
+++ b/bindings/scripts/v8_attributes.py
@@ -45,6 +45,19 @@ from v8_utilities import (cpp_name_or_partial, capitalize, cpp_name, has_extende
                           uncapitalize, extended_attribute_value_as_list, is_unforgeable,
                           is_legacy_interface_type_checking)
 
+numeric_cpp_type = set([
+    "double",
+    "float",
+    "bool",
+    "int8_t",
+    "int16_t",
+    "int32_t",
+    "int64_t",
+    "uint8_t",
+    "uint16_t",
+    "uint32_t",
+    "uint64_t"
+])
 
 def attribute_context(interface, attribute, interfaces):
     """Creates a Jinja template context for an attribute of an interface.
@@ -74,7 +87,11 @@ def attribute_context(interface, attribute, interfaces):
         is_cross_origin)
     is_check_security_for_return_value = (
         has_extended_attribute_value(attribute, 'CheckSecurity', 'ReturnValue'))
-    if is_check_security_for_receiver or is_check_security_for_return_value:
+    is_check_security_for_caller = (
+        (has_extended_attribute_value(interface, 'CheckSecurity', 'Caller') or
+        has_extended_attribute_value(attribute, 'CheckSecurity', 'Caller')) and
+        not is_cross_origin)
+    if is_check_security_for_receiver or is_check_security_for_return_value or is_check_security_for_caller:
         includes.add('bindings/core/v8/BindingSecurity.h')
     # [CrossOrigin]
     if has_extended_attribute_value(attribute, 'CrossOrigin', 'Setter'):
@@ -147,6 +164,7 @@ def attribute_context(interface, attribute, interfaces):
         'is_ce_reactions': is_ce_reactions,
         'is_check_security_for_receiver': is_check_security_for_receiver,
         'is_check_security_for_return_value': is_check_security_for_return_value,
+        'is_check_security_for_caller': is_check_security_for_caller,
         'is_custom_element_callbacks': is_custom_element_callbacks,
         # TODO(yukishiino): Make all DOM attributes accessor-type properties.
         'is_data_type_property': is_data_type_property(interface, attribute),
@@ -458,6 +476,8 @@ def setter_context(interface, attribute, interfaces, context):
         'is_setter_raises_exception': is_setter_raises_exception,
         'v8_value_to_local_cpp_value': idl_type.v8_value_to_local_cpp_value(
             extended_attributes, 'v8Value', 'cppValue'),
+        'is_string_attribute': str(idl_type.cpp_type) == "String",
+        'is_numeric_attribute': str(idl_type.cpp_type) in numeric_cpp_type,
     })
 
     # setter_expression() depends on context values we set above.
diff --git a/bindings/scripts/v8_interface.py b/bindings/scripts/v8_interface.py
index 234ed067..3cd4985d 100644
--- a/bindings/scripts/v8_interface.py
+++ b/bindings/scripts/v8_interface.py
@@ -239,7 +239,12 @@ def interface_context(interface, interfaces):
 
     # [CheckSecurity]
     is_check_security = 'CheckSecurity' in extended_attributes
-    if is_check_security:
+    is_cross_origin = 'CrossOrigin' in extended_attributes
+    is_check_security_for_caller = (
+        has_extended_attribute_value(interface, 'CheckSecurity', 'Caller') and
+        not is_cross_origin)
+    is_check_security = is_check_security and not is_check_security_for_caller
+    if is_check_security or is_check_security_for_caller:
         includes.add('bindings/core/v8/BindingSecurity.h')
         includes.add('core/frame/LocalDOMWindow.h')
 
@@ -284,6 +289,7 @@ def interface_context(interface, interfaces):
         'interface_name': interface.name,
         'is_array_buffer_or_view': is_array_buffer_or_view,
         'is_check_security': is_check_security,
+        'is_check_security_for_caller': is_check_security_for_caller,
         'is_event_target': is_event_target,
         'is_global': is_global,
         'is_immutable_prototype': is_immutable_prototype,
@@ -1314,6 +1320,14 @@ def constructor_context(interface, constructor):
         v8_methods.argument_context(interface, constructor, argument, index)
         for index, argument in enumerate(constructor.arguments)]
 
+    is_check_security_for_argument = (
+        any(argument_context['is_check_security_for_argument_element']
+        or argument_context['is_string_argument']
+        or argument_context['is_numeric_argument']
+        for argument_context in argument_contexts))
+    if is_check_security_for_argument:
+        includes.add('bindings/core/v8/BindingSecurity.h')
+
     return {
         'arguments': argument_contexts,
         'cpp_type': cpp_name(interface) + '*',
@@ -1422,6 +1436,15 @@ def property_getter(getter, cpp_arguments):
 
     cpp_value = '%s(%s)' % (cpp_method_name, ', '.join(cpp_arguments))
 
+    # [CheckSecurity]
+    is_cross_origin = 'CrossOrigin' in extended_attributes
+    is_check_security_for_caller = (
+        has_extended_attribute_value(getter, 'CheckSecurity', 'Caller') and
+        not is_cross_origin)
+    if is_check_security_for_caller:
+        includes.add('bindings/core/v8/BindingSecurity.h')
+        includes.add('core/frame/LocalDOMWindow.h')
+
     return {
         'cpp_type': idl_type.cpp_type,
         'cpp_value': cpp_value,
@@ -1440,6 +1463,7 @@ def property_getter(getter, cpp_arguments):
         'is_enumerable': 'NotEnumerable' not in extended_attributes,
         'is_null_expression': is_null_expression(idl_type),
         'is_raises_exception': is_raises_exception,
+        'is_check_security_for_caller': is_check_security_for_caller,
         'name': cpp_name(getter),
         'use_output_parameter_for_result': use_output_parameter_for_result,
         'v8_set_return_value': idl_type.v8_set_return_value('result', extended_attributes=extended_attributes, script_wrappable='impl'),
@@ -1462,6 +1486,15 @@ def property_setter(setter, interface):
         not is_legacy_interface_type_checking(interface, setter) and
         idl_type.is_wrapper_type)
 
+    # [CheckSecurity]
+    is_cross_origin = 'CrossOrigin' in extended_attributes
+    is_check_security_for_caller = (
+        has_extended_attribute_value(setter, 'CheckSecurity', 'Caller') and
+        not is_cross_origin)
+    if is_check_security_for_caller:
+        includes.add('bindings/core/v8/BindingSecurity.h')
+        includes.add('core/frame/LocalDOMWindow.h')
+
     return {
         'has_exception_state': (is_raises_exception or
                                 idl_type.v8_conversion_needs_exception_state),
@@ -1472,6 +1505,7 @@ def property_setter(setter, interface):
         'is_custom': 'Custom' in extended_attributes,
         'is_nullable': idl_type.is_nullable,
         'is_raises_exception': is_raises_exception,
+        'is_check_security_for_caller': is_check_security_for_caller,
         'name': cpp_name(setter),
         'v8_value_to_local_cpp_value': idl_type.v8_value_to_local_cpp_value(
             extended_attributes, 'v8Value', 'propertyValue'),
@@ -1485,10 +1519,21 @@ def property_deleter(deleter):
     extended_attributes = deleter.extended_attributes
     is_call_with_script_state = v8_utilities.has_extended_attribute_value(deleter, 'CallWith', 'ScriptState')
     is_ce_reactions = 'CEReactions' in extended_attributes
+
+    # [CheckSecurity]
+    is_cross_origin = 'CrossOrigin' in extended_attributes
+    is_check_security_for_caller = (
+        has_extended_attribute_value(deleter, 'CheckSecurity', 'Caller') and
+        not is_cross_origin)
+    if is_check_security_for_caller:
+        includes.add('bindings/core/v8/BindingSecurity.h')
+        includes.add('core/frame/LocalDOMWindow.h')
+
     return {
         'is_call_with_script_state': is_call_with_script_state,
         'is_ce_reactions': is_ce_reactions,
         'is_custom': 'Custom' in extended_attributes,
         'is_raises_exception': 'RaisesException' in extended_attributes,
+        'is_check_security_for_caller': is_check_security_for_caller,
         'name': cpp_name(deleter),
     }
diff --git a/bindings/scripts/v8_methods.py b/bindings/scripts/v8_methods.py
index df3d921c..4fc2c440 100644
--- a/bindings/scripts/v8_methods.py
+++ b/bindings/scripts/v8_methods.py
@@ -42,6 +42,35 @@ import v8_utilities
 from v8_utilities import (has_extended_attribute_value, is_unforgeable,
                           is_legacy_interface_type_checking)
 
+element_idl_list = set([
+    "(HTMLElement or long)",
+    "(HTMLImageElement or HTMLVideoElement or HTMLCanvasElement or ImageBitmap)",
+    "(HTMLOptionElement or HTMLOptGroupElement)",
+    "(NodeList or Element)",
+    "Element",
+    "ElementRegistrationOptions",
+#    "Element[]",
+    "HTMLCanvasElement",
+    "HTMLFormElement",
+    "HTMLImageElement",
+    "HTMLMediaElement",
+    "HTMLSelectElement",
+    "HTMLVideoElement",
+    "SVGElement",
+])
+numeric_cpp_type = set([
+    "double",
+    "float",
+    "bool",
+    "int8_t",
+    "int16_t",
+    "int32_t",
+    "int64_t",
+    "uint8_t",
+    "uint16_t",
+    "uint32_t",
+    "uint64_t"
+])
 
 def method_is_visible(method, interface_is_partial):
     if 'overloads' in method:
@@ -148,7 +177,17 @@ def method_context(interface, method, is_visible=True):
         not is_cross_origin)
     is_check_security_for_return_value = (
         has_extended_attribute_value(method, 'CheckSecurity', 'ReturnValue'))
-    if is_check_security_for_receiver or is_check_security_for_return_value:
+    is_check_security_for_caller = (
+        (has_extended_attribute_value(interface, 'CheckSecurity', 'Caller') or
+        has_extended_attribute_value(method, 'CheckSecurity', 'Caller')) and
+        not is_cross_origin)
+    is_check_security_for_write_self = (
+        has_extended_attribute_value(method, 'CheckSecurity', 'WriteSelf') and
+        not is_cross_origin)
+    is_check_security_for_creation = (
+        has_extended_attribute_value(method, 'CheckSecurity', 'Creation') and
+        not is_cross_origin)
+    if is_check_security_for_receiver or is_check_security_for_return_value or is_check_security_for_caller or is_check_security_for_write_self or is_check_security_for_creation:
         includes.add('bindings/core/v8/BindingSecurity.h')
 
     is_ce_reactions = 'CEReactions' in extended_attributes
@@ -175,6 +214,14 @@ def method_context(interface, method, is_visible=True):
         argument_context(interface, method, argument, index, is_visible=is_visible)
         for index, argument in enumerate(arguments)]
 
+    is_check_security_for_argument = (
+        any(argument_context['is_check_security_for_argument_element']
+            or argument_context['is_string_argument']
+            or argument_context['is_numeric_argument']
+        for argument_context in argument_contexts))
+    if is_check_security_for_argument:
+        includes.add('bindings/core/v8/BindingSecurity.h')
+
     return {
         'activity_logging_world_list': v8_utilities.activity_logging_world_list(method),  # [ActivityLogging]
         'arguments': argument_contexts,
@@ -188,6 +235,8 @@ def method_context(interface, method, is_visible=True):
         'has_exception_state':
             is_raises_exception or
             is_check_security_for_receiver or
+            is_check_security_for_caller or
+            is_check_security_for_write_self or
             any(argument for argument in arguments
                 if (argument.idl_type.name == 'SerializedScriptValue' or
                     argument_conversion_needs_exception_state(method, argument))),
@@ -202,6 +251,9 @@ def method_context(interface, method, is_visible=True):
         'is_ce_reactions': is_ce_reactions,
         'is_check_security_for_receiver': is_check_security_for_receiver,
         'is_check_security_for_return_value': is_check_security_for_return_value,
+        'is_check_security_for_caller': is_check_security_for_caller,
+        'is_check_security_for_write_self': is_check_security_for_write_self,
+        'is_check_security_for_creation': is_check_security_for_creation,
         'is_cross_origin': 'CrossOrigin' in extended_attributes,
         'is_custom': 'Custom' in extended_attributes and
             not (is_custom_call_prologue or is_custom_call_epilogue),
@@ -249,6 +301,10 @@ def method_context(interface, method, is_visible=True):
 def argument_context(interface, method, argument, index, is_visible=True):
     extended_attributes = argument.extended_attributes
     idl_type = argument.idl_type
+    is_check_security_for_argument_element = str(idl_type) in element_idl_list
+    #if is_check_security_for_argument_element:
+        #print interface.idl_type, method.name, method.idl_type, idl_type
+
     if is_visible:
         idl_type.add_includes_for_type(extended_attributes)
     this_cpp_value = cpp_value(interface, method, index)
@@ -263,6 +319,9 @@ def argument_context(interface, method, argument, index, is_visible=True):
     this_cpp_type = idl_type.cpp_type_args(extended_attributes=extended_attributes,
                                            raw_type=True,
                                            used_as_variadic_argument=argument.is_variadic)
+    cpp_type = v8_types.cpp_template_type('Nullable', this_cpp_type) if idl_type.is_explicit_nullable and not argument.is_variadic else this_cpp_type
+    is_string_argument = 'DOMString' == str(idl_type) and str(cpp_type).startswith('V8StringResource')
+
     context = {
         'cpp_type': (
             v8_types.cpp_template_type('Nullable', this_cpp_type)
@@ -296,6 +355,9 @@ def argument_context(interface, method, argument, index, is_visible=True):
         'v8_set_return_value': v8_set_return_value(interface.name, method, this_cpp_value),
         'v8_set_return_value_for_main_world': v8_set_return_value(interface.name, method, this_cpp_value, for_main_world=True),
         'v8_value_to_local_cpp_value': v8_value_to_local_cpp_value(interface.name, method, argument, index),
+        'is_check_security_for_argument_element': is_check_security_for_argument_element,
+        'is_string_argument': is_string_argument,
+        'is_numeric_argument': str(idl_type.cpp_type) in numeric_cpp_type,
     }
     context.update({
         'is_optional_without_default_value':
diff --git a/bindings/templates/attributes.cpp.tmpl b/bindings/templates/attributes.cpp.tmpl
index 33e93e9d..685eb667 100644
--- a/bindings/templates/attributes.cpp.tmpl
+++ b/bindings/templates/attributes.cpp.tmpl
@@ -112,6 +112,12 @@ const v8::FunctionCallbackInfo<v8::Value>& info
   }
   {% endif %}
 
+  {% if attribute.is_check_security_for_caller %}
+  // Perform a security check for target.
+  {{define_exception_state}}
+  BindingSecurity::LogAccessToElement(CurrentDOMWindow(info.GetIsolate()), impl, ATTEMPT_TO_READ, "{{attribute.name}}", exceptionState);
+  {% endif %}
+
   {% if attribute.is_call_with_execution_context %}
   {% if attribute.is_static %}
   ExecutionContext* executionContext = ExecutionContext::ForCurrentRealm(info);
@@ -434,6 +440,31 @@ v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info
   {% if attribute.is_explicit_nullable %}
   bool isNull = IsUndefinedOrNull(v8Value);
   {% endif %}
+
+  {% if not attribute.is_static and not attribute.is_replaceable and not attribute.is_put_forwards %}
+  {{define_exception_state}}
+
+  {% if attribute.is_check_security_for_caller %}
+  String string_arguments_str = "";
+  {% if attribute.is_string_attribute or attribute.is_numeric_attribute %}
+  string_arguments_str.append(", \"value\": ");
+  {% if attribute.is_string_attribute %}
+  String _temp_string_ = cppValue;
+  {% elif attribute.is_numeric_attribute %}
+  String _temp_string_ = String::Number(cppValue);
+  {% endif %}{# if attribute.is_string_attribute #}
+  string_arguments_str.append(JSONValue::QuoteString(_temp_string_));
+  {% endif %}{# if attribute.is_string_attribute or attribute.is_numeric_attribute #}
+
+
+  {% if attribute.is_check_security_for_caller %}
+  // Perform a security check for target.
+    BindingSecurity::LogAccessToElement(CurrentDOMWindow(info.GetIsolate()), impl, ATTEMPT_TO_WRITE, "{{attribute.name}}", exceptionState, string_arguments_str);
+
+  {% endif %}{# attribute.is_check_security_for_caller #}
+  {% endif %}{# if attribute.is_check_security_for_caller #}
+  {% endif %}{# if not attribute.is_static and not attribute.is_replaceable and not attribute.is_put_forwards #}
+
   {{attribute.cpp_setter}};
 
   {% if attribute.cached_attribute_validation_method %}
diff --git a/bindings/templates/interface.cpp.tmpl b/bindings/templates/interface.cpp.tmpl
index eea0a350..b0f0d7b3 100644
--- a/bindings/templates/interface.cpp.tmpl
+++ b/bindings/templates/interface.cpp.tmpl
@@ -7,12 +7,16 @@
 {% if indexed_property_getter and not indexed_property_getter.is_custom %}
 {% set getter = indexed_property_getter %}
 static void indexedPropertyGetter(uint32_t index, const v8::PropertyCallbackInfo<v8::Value>& info) {
-  {% if getter.is_raises_exception %}
+  {% if getter.is_raises_exception or getter.is_check_security_for_caller %}
   ExceptionState exceptionState(info.GetIsolate(), ExceptionState::kIndexedGetterContext, "{{interface_name}}");
   {% endif %}
 
   {{cpp_class}}* impl = {{v8_class}}::ToImpl(info.Holder());
 
+  {% if getter.is_check_security_for_caller %}
+    BindingSecurity::LogAccessToElement(CurrentDOMWindow(info.GetIsolate()), impl, ATTEMPT_TO_READ, "indexedPropertyGetter", exceptionState);
+  {% endif %}
+
   // We assume that all the implementations support length() method, although
   // the spec doesn't require that length() must exist.  It's okay that
   // the interface does not have length attribute as long as the
@@ -74,12 +78,17 @@ void {{v8_class_or_partial}}::indexedPropertyGetterCallback(uint32_t index, cons
 {% if indexed_property_setter and not indexed_property_setter.is_custom %}
 {% set setter = indexed_property_setter %}
 static void indexedPropertySetter(uint32_t index, v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<v8::Value>& info) {
-  {% if setter.has_exception_state %}
+  {% if setter.has_exception_state or setter.is_check_security_for_caller %}
   ExceptionState exceptionState(info.GetIsolate(), ExceptionState::kIndexedSetterContext, "{{interface_name}}");
   {% endif %}
 
   {{cpp_class}}* impl = {{v8_class}}::ToImpl(info.Holder());
   {{v8_value_to_local_cpp_value(setter) | indent(2)}}
+
+  {% if setter.is_check_security_for_caller %}
+    BindingSecurity::LogAccessToElement(CurrentDOMWindow(info.GetIsolate()), impl, ATTEMPT_TO_WRITE, "indexedPropertySetter", exceptionState);
+  {% endif %}
+
   {% if setter.has_type_checking_interface %}
   {# Type checking for interface types (if interface not implemented, throw
      TypeError), per http://www.w3.org/TR/WebIDL/#es-interface #}
@@ -264,12 +273,16 @@ void {{v8_class_or_partial}}::indexedPropertyDescriptorCallback(uint32_t index,
 {% if indexed_property_deleter and not indexed_property_deleter.is_custom %}
 {% set deleter = indexed_property_deleter %}
 static void indexedPropertyDeleter(uint32_t index, const v8::PropertyCallbackInfo<v8::Boolean>& info) {
-  {% if deleter.is_raises_exception %}
+  {% if deleter.is_raises_exception or deleter.is_check_security_for_caller %}
   ExceptionState exceptionState(info.GetIsolate(), ExceptionState::kIndexedDeletionContext, "{{interface_name}}");
   {% endif %}
 
   {{cpp_class}}* impl = {{v8_class}}::ToImpl(info.Holder());
 
+  {% if deleter.is_check_security_for_caller %}
+    BindingSecurity::LogAccessToElement(CurrentDOMWindow(info.GetIsolate()), impl, ATTEMPT_TO_WRITE, "indexedPropertyDeleter", exceptionState);
+  {% endif %}
+
   {% set deleter_name = deleter.name or 'AnonymousIndexedDeleter' %}
   {% set deleter_arguments = ['index'] %}
   {% if deleter.is_call_with_script_state %}
@@ -379,7 +392,7 @@ void {{v8_class_or_partial}}::indexedPropertyDefinerCallback(
 {% if named_property_getter and not named_property_getter.is_custom %}
 {% set getter = named_property_getter %}
 static void namedPropertyGetter(const AtomicString& name, const v8::PropertyCallbackInfo<v8::Value>& info) {
-  {% if getter.is_raises_exception %}
+  {% if getter.is_raises_exception or getter.is_check_security_for_caller %}
   const CString& nameInUtf8 = name.Utf8();
   ExceptionState exceptionState(info.GetIsolate(), ExceptionState::kGetterContext, "{{interface_name}}", nameInUtf8.data());
   {% endif %}
@@ -388,6 +401,11 @@ static void namedPropertyGetter(const AtomicString& name, const v8::PropertyCall
   {% endif %}
 
   {{cpp_class}}* impl = {{v8_class}}::ToImpl(info.Holder());
+
+  {% if getter.is_check_security_for_caller %}
+    BindingSecurity::LogAccessToElement(CurrentDOMWindow(info.GetIsolate()), impl, ATTEMPT_TO_READ, "namedPropertyGetter", exceptionState);
+  {% endif %}
+
   {% if getter.use_output_parameter_for_result %}
   {{getter.cpp_type}} result;
   {{getter.cpp_value}};
@@ -430,7 +448,7 @@ void {{v8_class_or_partial}}::namedPropertyGetterCallback(v8::Local<v8::Name> na
 {% if named_property_setter and not named_property_setter.is_custom %}
 {% set setter = named_property_setter %}
 static void namedPropertySetter(const AtomicString& name, v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<v8::Value>& info) {
-  {% if setter.has_exception_state %}
+  {% if setter.has_exception_state or setter.is_check_security_for_caller %}
   const CString& nameInUtf8 = name.Utf8();
   ExceptionState exceptionState(info.GetIsolate(), ExceptionState::kSetterContext, "{{interface_name}}", nameInUtf8.data());
   {% endif %}
@@ -440,6 +458,12 @@ static void namedPropertySetter(const AtomicString& name, v8::Local<v8::Value> v
 
   {{cpp_class}}* impl = {{v8_class}}::ToImpl(info.Holder());
   {{v8_value_to_local_cpp_value(setter) | indent(2)}}
+
+  {% if setter.is_check_security_for_caller %}
+    BindingSecurity::LogAccessToElement(CurrentDOMWindow(info.GetIsolate()), impl, ATTEMPT_TO_WRITE, "namedPropertySetter", exceptionState);
+    exceptionState.throwIfNeeded();
+  {% endif %}
+
   {% if setter.has_type_checking_interface %}
   {# Type checking for interface types (if interface not implemented, throw
      TypeError), per http://www.w3.org/TR/WebIDL/#es-interface #}
@@ -501,7 +525,7 @@ void {{v8_class_or_partial}}::namedPropertySetterCallback(v8::Local<v8::Name> na
 {% if named_property_deleter and not named_property_deleter.is_custom %}
 {% set deleter = named_property_deleter %}
 static void namedPropertyDeleter(const AtomicString& name, const v8::PropertyCallbackInfo<v8::Boolean>& info) {
-  {% if deleter.is_raises_exception %}
+  {% if deleter.is_raises_exception or deleter.is_check_security_for_caller %}
   const CString& nameInUtf8 = name.Utf8();
   ExceptionState exceptionState(info.GetIsolate(), ExceptionState::kDeletionContext, "{{interface_name}}", nameInUtf8.data());
   {% endif %}
@@ -511,6 +535,10 @@ static void namedPropertyDeleter(const AtomicString& name, const v8::PropertyCal
 
   {{cpp_class}}* impl = {{v8_class}}::ToImpl(info.Holder());
 
+  {% if deleter.is_check_security_for_caller %}
+    BindingSecurity::LogAccessToElement(CurrentDOMWindow(info.GetIsolate()), impl, ATTEMPT_TO_WRITE, "namedPropertyDeleter", exceptionState);
+  {% endif %}
+
   {% set deleter_name = deleter.name or 'AnonymousNamedDeleter' %}
   {% set deleter_arguments = ['name'] %}
   {% if deleter.is_call_with_script_state %}
@@ -584,6 +612,10 @@ static void namedPropertyQuery(const AtomicString& name, const v8::PropertyCallb
 
   {{cpp_class}}* impl = {{v8_class}}::ToImpl(info.Holder());
 
+  {% if getter.is_check_security_for_caller %}
+    BindingSecurity::LogAccessToElement(CurrentDOMWindow(info.GetIsolate()), impl, ATTEMPT_TO_READ, "namedPropertyQuery", exceptionState);
+  {% endif %}
+
   {% set getter_arguments = ['name', 'exceptionState'] %}
   {% if getter.is_call_with_script_state %}
   {% set getter_arguments = ['scriptState'] + getter_arguments %}
@@ -642,6 +674,10 @@ static void namedPropertyEnumerator(const v8::PropertyCallbackInfo<v8::Array>& i
 
   {{cpp_class}}* impl = {{v8_class}}::ToImpl(info.Holder());
 
+  {% if named_property_getter.is_check_security_for_caller %}
+    BindingSecurity::LogAccessToElement(CurrentDOMWindow(info.GetIsolate()), impl, ATTEMPT_TO_READ, "namedPropertyEnumerator", exceptionState);
+  {% endif %}
+
   Vector<String> names;
   impl->NamedPropertyEnumerator(names, exceptionState);
   if (exceptionState.HadException())
diff --git a/bindings/templates/methods.cpp.tmpl b/bindings/templates/methods.cpp.tmpl
index f862a23a..a241a33f 100644
--- a/bindings/templates/methods.cpp.tmpl
+++ b/bindings/templates/methods.cpp.tmpl
@@ -81,6 +81,78 @@ static void {{method.name}}{{method.overload_index}}Method{{world_suffix}}(const
 {######################################}
 {% macro func_call_with_prep_of_args(method, world_suffix) %}
 {{generate_arguments(method, world_suffix)}}
+{% if method.is_check_security_for_caller %}
+{{define_exception_state}}
+String string_arguments_str = ", \"args\": {";
+
+{% if method.arguments %}
+{% for argument in method.arguments %}
+{% if argument.is_string_argument or argument.is_numeric_argument %}
+{% if argument.is_string_argument %}
+String _temp_string_{{argument.index}} = {{method.arguments[argument.index].name}};
+{% elif argument.is_numeric_argument %}
+String _temp_string_{{argument.index}} = String::Number({{method.arguments[argument.index].name}});
+{% endif %}
+string_arguments_str.append("\"{{argument.index}}\": ");
+string_arguments_str.append(JSONValue::QuoteString(_temp_string_{{argument.index}}));
+string_arguments_str.append(",");
+{% endif %}
+{% endfor %}
+{% endif %}{# if method.arguments #}
+
+if (string_arguments_str.length() > 11)
+  string_arguments_str.replace(string_arguments_str.length()-1, 1, "}");
+else
+  string_arguments_str = "";
+
+{% if method.is_check_security_for_write_self %}
+{% if method.name in ('setAttribute', 'removeAttribute') %}
+{% if method.arguments and method.arguments[0] %}
+const char* href_str = "href";
+String _temp_string_ = {{method.arguments[0].name}};
+if (_temp_string_ == href_str)
+  BindingSecurity::LogAccessToElement(CurrentDOMWindow(info.GetIsolate()), impl, ATTEMPT_TO_WRITE_EXECUTE, "{{method.name}}()", exceptionState, string_arguments_str);
+{% endif %}{# if method.arguments and method.arguments[0] #}
+
+{% elif method.name in ('setAttributeNS', 'removeAttributeNS') %}
+{% if method.arguments and method.arguments[1] %}
+String _temp_string_ns_ = {{method.arguments[1].name}};
+const char* href_str_ns = "href";
+if (_temp_string_ns_== href_str_ns)
+  BindingSecurity::LogAccessToElement(CurrentDOMWindow(info.GetIsolate()), impl, ATTEMPT_TO_WRITE_EXECUTE, "{{method.name}}()", exceptionState, string_arguments_str);
+{% endif %}{# if method.arguments and method.arguments[1] #}
+
+{% else %}
+  BindingSecurity::LogAccessToElement(CurrentDOMWindow(info.GetIsolate()), impl, ATTEMPT_TO_WRITE_EXECUTE, "{{method.name}}()", exceptionState, string_arguments_str);
+{% endif %}{# if method.name in ('setAttribute', 'removeAttribute') #}
+
+
+
+{% else %}
+{% if method.name in ('setAttribute', 'removeAttribute') %}
+{% if method.arguments and method.arguments[0] %}
+const char* href_str = "href";
+String _temp_string_ = {{method.arguments[0].name}};
+if (_temp_string_ == href_str)
+  BindingSecurity::LogAccessToElement(CurrentDOMWindow(info.GetIsolate()), impl, ATTEMPT_TO_EXECUTE, "{{method.name}}()", exceptionState, string_arguments_str);
+{% endif %}{# if method.arguments and method.arguments[0] #}
+
+{% elif method.name in ('setAttributeNS', 'removeAttributeNS') %}
+{% if method.arguments and method.arguments[1] %}
+String _temp_string_ns_ = {{method.arguments[1].name}};
+const char* href_str_ns = "href";
+if (_temp_string_ns_==href_str_ns)
+  BindingSecurity::LogAccessToElement(CurrentDOMWindow(info.GetIsolate()), impl, ATTEMPT_TO_EXECUTE, "{{method.name}}()", exceptionState, string_arguments_str);
+{% endif %}{# if method.arguments and method.arguments[1] #}
+
+{% else %}
+BindingSecurity::LogAccessToElement(CurrentDOMWindow(info.GetIsolate()), impl, ATTEMPT_TO_EXECUTE, "{{method.name}}()", exceptionState, string_arguments_str);
+
+{% endif %}{# if method.name in ('setAttribute', 'removeAttribute') #}
+{% endif %}{# if method.is_check_security_for_write_self #}
+{% endif %}{# if method.is_check_security_for_caller #}
+
+{# Call method #}
 {% if world_suffix %}
 {{cpp_method_call(method, method.v8_set_return_value_for_main_world, method.cpp_value)}}
 {% else %}
@@ -117,6 +189,7 @@ while (numArgsPassed > 0) {
   --numArgsPassed;
 }
 {% endif %}
+
 {% for argument in method.arguments %}
 {% if argument.set_default_value %}
 if (!info[{{argument.index}}]->IsUndefined()) {
@@ -127,6 +200,12 @@ if (!info[{{argument.index}}]->IsUndefined()) {
 {% else %}
 {{generate_argument(method, argument, world_suffix)}}
 {% endif %}
+
+{% if argument.is_check_security_for_argument_element %}
+Element *_ele_{{argument.index}} = V8Element::ToImplWithTypeCheck(info.GetIsolate(), info[{{argument.index}}]);
+if (_ele_{{argument.index}})
+  BindingSecurity::LogAccessToElement(CurrentDOMWindow(info.GetIsolate()), _ele_{{argument.index}}, ATTEMPT_TO_READ, "{{method.name}}({{argument.index}})");
+{% endif %}{# if argument.is_check_security_for_argument_element #}
 {% endfor %}
 
 {% endif %}{# method.arguments #}
@@ -282,6 +361,10 @@ Document& document = *ToDocument(ToExecutionContext(
 {% elif method.use_local_result %}
 {{method.cpp_type}} result = {{cpp_value}};
 {% endif %}
+{% if method.is_check_security_for_creation %}
+BindingSecurity::SetNodeAndChildrenInitiator(impl, result, true);
+{% endif %}{# if method.is_check_security_for_creation #}
+
 {# Post-call #}
 {% if method.is_raises_exception %}
 if (exceptionState.HadException()) {
diff --git a/core/css/CSSComputedStyleDeclaration.cpp b/core/css/CSSComputedStyleDeclaration.cpp
index c202bb27..3b3d0f52 100644
--- a/core/css/CSSComputedStyleDeclaration.cpp
+++ b/core/css/CSSComputedStyleDeclaration.cpp
@@ -299,6 +299,11 @@ LayoutObject* CSSComputedStyleDeclaration::StyledLayoutObject() const {
   return node->GetLayoutObject();
 }
 
+Node* CSSComputedStyleDeclaration::parentNode() const
+{
+    return this->StyledNode();
+}
+
 const CSSValue* CSSComputedStyleDeclaration::GetPropertyCSSValue(
     AtomicString custom_property_name) const {
   Node* styled_node = StyledNode();
diff --git a/core/css/CSSComputedStyleDeclaration.h b/core/css/CSSComputedStyleDeclaration.h
index 69a02f5a..d1769a12 100644
--- a/core/css/CSSComputedStyleDeclaration.h
+++ b/core/css/CSSComputedStyleDeclaration.h
@@ -85,6 +85,7 @@ class CORE_EXPORT CSSComputedStyleDeclaration final
   // on Elements, but right now editing creates these for text nodes. We should
   // fix that.
   Node* StyledNode() const;
+  Node* parentNode() const override;
 
   // The styled layout object is the layout object corresponding to the node
   // being queried, if any.
diff --git a/core/css/CSSStyleDeclaration.h b/core/css/CSSStyleDeclaration.h
index 9930c18d..9ea30828 100644
--- a/core/css/CSSStyleDeclaration.h
+++ b/core/css/CSSStyleDeclaration.h
@@ -37,6 +37,7 @@ class CSSStyleSheet;
 class CSSValue;
 class ExceptionState;
 enum class SecureContextMode;
+class Node;
 
 class CORE_EXPORT CSSStyleDeclaration : public ScriptWrappable {
   DEFINE_WRAPPERTYPEINFO();
@@ -44,6 +45,7 @@ class CORE_EXPORT CSSStyleDeclaration : public ScriptWrappable {
  public:
   virtual ~CSSStyleDeclaration() = default;
 
+  virtual Node* parentNode() const = 0;
   virtual CSSRule* parentRule() const = 0;
   String cssFloat() { return GetPropertyValueInternal(CSSPropertyFloat); }
   void setCSSFloat(const ExecutionContext* execution_context,
diff --git a/core/css/PropertySetCSSStyleDeclaration.cpp b/core/css/PropertySetCSSStyleDeclaration.cpp
index 8845b3fb..d7856aba 100644
--- a/core/css/PropertySetCSSStyleDeclaration.cpp
+++ b/core/css/PropertySetCSSStyleDeclaration.cpp
@@ -347,6 +347,11 @@ StyleSheetContents* AbstractPropertySetCSSStyleDeclaration::ContextStyleSheet()
   return css_style_sheet ? css_style_sheet->Contents() : nullptr;
 }
 
+Node* InlineCSSStyleDeclaration::parentNode() const
+{
+    return parent_element_;
+}
+
 bool AbstractPropertySetCSSStyleDeclaration::CssPropertyMatches(
     CSSPropertyID property_id,
     const CSSValue* property_value) const {
diff --git a/core/css/PropertySetCSSStyleDeclaration.h b/core/css/PropertySetCSSStyleDeclaration.h
index f7156aae..0938e034 100644
--- a/core/css/PropertySetCSSStyleDeclaration.h
+++ b/core/css/PropertySetCSSStyleDeclaration.h
@@ -40,9 +40,11 @@ class ExecutionContext;
 class MutableCSSPropertyValueSet;
 class PropertyRegistry;
 class StyleSheetContents;
+class Node;
 
 class AbstractPropertySetCSSStyleDeclaration : public CSSStyleDeclaration {
  public:
+  virtual Node* parentNode() const { return nullptr; }
   virtual Element* ParentElement() const { return nullptr; }
   StyleSheetContents* ContextStyleSheet() const;
 
@@ -148,6 +150,7 @@ class InlineCSSStyleDeclaration final
  private:
   MutableCSSPropertyValueSet& PropertySet() const override;
   CSSStyleSheet* ParentStyleSheet() const override;
+  Node* parentNode() const override;
   Element* ParentElement() const override { return parent_element_; }
 
   void DidMutate(MutationType) override;
diff --git a/core/dom/BUILD.gn b/core/dom/BUILD.gn
index c72e5afb..47f5d78b 100644
--- a/core/dom/BUILD.gn
+++ b/core/dom/BUILD.gn
@@ -211,6 +211,8 @@ blink_core_sources("dom") {
     "NonElementParentNode.h",
     "NthIndexCache.cpp",
     "NthIndexCache.h",
+    "Observer.cpp",
+    "Observer.h",
     "ParentNode.h",
     "ParserContentPolicy.h",
     "PausableObject.cpp",
diff --git a/core/dom/Document.cpp b/core/dom/Document.cpp
index e4308594..51478692 100644
--- a/core/dom/Document.cpp
+++ b/core/dom/Document.cpp
@@ -655,11 +655,15 @@ Document::Document(const DocumentInit& initializer,
       has_viewport_units_(false),
       parser_sync_policy_(kAllowAsynchronousParsing),
       node_count_(0),
+      unique_node_count_(0),
       would_load_reason_(WouldLoadReason::kInvalid),
       password_count_(0),
       logged_field_edit_(false),
       engagement_level_(mojom::blink::EngagementLevel::NONE),
-      secure_context_state_(SecureContextState::kUnknown) {
+      secure_context_state_(SecureContextState::kUnknown),
+      access_count_(0),
+      inserted_script_count_(0),
+      is_sensitive_apis_disabled(false) {
   if (frame_) {
     DCHECK(frame_->GetPage());
     ProvideContextFeaturesToDocumentFrom(*this, *frame_->GetPage());
@@ -6700,6 +6704,31 @@ bool Document::ThreadedParsingEnabledForTesting() {
   return g_threaded_parsing_enabled_for_testing;
 }
 
+
+AtomicString Document::scriptIDMap() {
+  AtomicString result = AtomicString(m_documentInfoManager.scriptIDMapString());
+  return result;
+}
+
+
+AtomicString Document::apiLog() {
+  AtomicString result = AtomicString(m_documentInfoManager.getAPILogs());
+  m_documentInfoManager.clearAPILogs();
+  return result;
+}
+
+void Document::setCurrentFiredEvent(Event *event) {
+  Node *target_node = event->target()->ToNode();
+  if (target_node) {
+    m_documentInfoManager.setCurrentEventTarget(target_node->getNid());
+    m_documentInfoManager.setCurrentEventType(event->type());
+  }
+}
+
+void Document::appendAPILog(const String& log) {
+  m_documentInfoManager.appendAPILog(log);
+}
+
 SnapCoordinator* Document::GetSnapCoordinator() {
   if (RuntimeEnabledFeatures::CSSScrollSnapPointsEnabled() &&
       !snap_coordinator_)
diff --git a/core/dom/Document.h b/core/dom/Document.h
index d3ff6bc8..fb78a70d 100644
--- a/core/dom/Document.h
+++ b/core/dom/Document.h
@@ -1345,13 +1345,36 @@ class CORE_EXPORT Document : public ContainerNode,
   static void SetThreadedParsingEnabledForTesting(bool);
   static bool ThreadedParsingEnabledForTesting();
 
-  void IncrementNodeCount() { node_count_++; }
+  void IncrementNodeCount() { node_count_++; unique_node_count_++; }
   void DecrementNodeCount() {
     DCHECK_GT(node_count_, 0);
     node_count_--;
   }
   int NodeCount() const { return node_count_; }
 
+  int UniqueNodeCount() const { return unique_node_count_; }
+
+  int accessCount() { return access_count_++; }
+
+  int insertedScriptCount() { return inserted_script_count_++; }
+
+
+  AtomicString scriptIDMap();
+  bool setScriptID2URL(const int, const String&);
+  bool setScriptID2ParentScriptID(const int, const String&);
+  const String& getScriptID2URL(const int);
+
+  AtomicString apiLog();
+
+  int getCurrentEventTarget();
+  const AtomicString& getCurrentEventType();
+  void setCurrentFiredEvent(Event*);
+  void appendAPILog(const String&);
+
+  void disableSensitiveAPIs() { is_sensitive_apis_disabled = true; }
+  void enableSensitiveAPIs() { is_sensitive_apis_disabled = false; }
+  bool isSensitiveAPIsDisabled() { return is_sensitive_apis_disabled; }
+
   SnapCoordinator* GetSnapCoordinator();
 
   void EnforceInsecureRequestPolicy(WebInsecureRequestPolicy);
@@ -1776,6 +1799,7 @@ class CORE_EXPORT Document : public ContainerNode,
   Member<ResizeObserverController> resize_observer_controller_;
 
   int node_count_;
+  int unique_node_count_;
 
   bool may_contain_v0_shadow_ = false;
 
@@ -1808,6 +1832,11 @@ class CORE_EXPORT Document : public ContainerNode,
   // the document to recorde UKM.
   std::unique_ptr<ukm::UkmRecorder> ukm_recorder_;
   int64_t ukm_source_id_;
+
+  DocumentInfoManager m_documentInfoManager;
+  int access_count_;
+  int inserted_script_count_;
+  bool is_sensitive_apis_disabled;
 };
 
 extern template class CORE_EXTERN_TEMPLATE_EXPORT Supplement<Document>;
@@ -1828,6 +1857,31 @@ inline void Document::ScheduleLayoutTreeUpdateIfNeeded() {
     ScheduleLayoutTreeUpdate();
 }
 
+inline bool Document::setScriptID2URL(
+    const int scriptID, const String& sourceURL) {
+  return m_documentInfoManager.setScriptID2URL(
+      scriptID, sourceURL);
+}
+
+inline bool Document::setScriptID2ParentScriptID(
+    const int scriptID, const String& parentScriptID) {
+  return m_documentInfoManager.setScriptID2ParentScriptID(
+      scriptID, parentScriptID);
+}
+
+inline const String& Document::getScriptID2URL(
+    const int scriptID) {
+  return m_documentInfoManager.getScriptID2URL(scriptID);
+}
+
+inline int Document::getCurrentEventTarget() {
+  return m_documentInfoManager.getCurrentEventTarget();
+}
+
+inline const AtomicString& Document::getCurrentEventType() {
+  return m_documentInfoManager.getCurrentEventType();
+}
+
 DEFINE_TYPE_CASTS(Document,
                   ExecutionContext,
                   context,
diff --git a/core/dom/Document.idl b/core/dom/Document.idl
index 6005bd54..c59ddf22 100644
--- a/core/dom/Document.idl
+++ b/core/dom/Document.idl
@@ -41,6 +41,9 @@ typedef (HTMLScriptElement or SVGScriptElement) HTMLOrSVGScriptElement;
 ] interface Document : Node {
     [SameObject] readonly attribute DOMImplementation implementation;
     [ImplementedAs=urlForBinding] readonly attribute DOMString URL;
+    readonly attribute DOMString scriptIDMap;
+    readonly attribute DOMString apiLog;
+
     // FIXME: documentURI should not be nullable.
     [ImplementedAs=urlForBinding] readonly attribute DOMString? documentURI;
     [MeasureAs=DocumentOrigin] readonly attribute DOMString origin;
@@ -58,8 +61,11 @@ typedef (HTMLScriptElement or SVGScriptElement) HTMLOrSVGScriptElement;
     HTMLCollection getElementsByTagNameNS(DOMString? namespaceURI, DOMString localName);
     HTMLCollection getElementsByClassName(DOMString classNames);
 
-    [NewObject, DoNotTestNewObject, CustomElementCallbacks, PerWorldBindings, RaisesException] Element createElement(DOMString localName);
-    [NewObject, DoNotTestNewObject, CustomElementCallbacks, RaisesException] Element createElementNS(DOMString? namespaceURI, DOMString qualifiedName);
+    void disableSensitiveAPIs();
+    void enableSensitiveAPIs();
+
+    [NewObject, DoNotTestNewObject, CustomElementCallbacks, PerWorldBindings, RaisesException, CheckSecurity=Creation] Element createElement(DOMString localName);
+    [NewObject, DoNotTestNewObject, CustomElementCallbacks, RaisesException, CheckSecurity=Creation] Element createElementNS(DOMString? namespaceURI, DOMString qualifiedName);
     [NewObject] DocumentFragment createDocumentFragment();
     [NewObject] Text createTextNode(DOMString data);
     [NewObject, RaisesException] CDATASection createCDATASection(DOMString data);
@@ -196,8 +202,8 @@ typedef (HTMLScriptElement or SVGScriptElement) HTMLOrSVGScriptElement;
     [CallWith=ScriptState, CustomElementCallbacks, RaisesException, MeasureAs=DocumentRegisterElement] CustomElementConstructor registerElement(DOMString type, optional ElementRegistrationOptions options);
     // https://w3c.github.io/webcomponents/spec/custom/#extensions-to-document-interface-to-instantiate
     // FIXME: The typeExtension arguments should not be nullable.
-    [CustomElementCallbacks, PerWorldBindings, RaisesException] Element createElement(DOMString localName, (DOMString or Dictionary)? options);
-    [CustomElementCallbacks, RaisesException] Element createElementNS(DOMString? namespaceURI, DOMString qualifiedName, (DOMString or Dictionary)? options);
+    [CustomElementCallbacks, PerWorldBindings, RaisesException, CheckSecurity=Creation] Element createElement(DOMString localName, (DOMString or Dictionary)? options);
+    [CustomElementCallbacks, RaisesException, CheckSecurity=Creation] Element createElementNS(DOMString? namespaceURI, DOMString qualifiedName, (DOMString or Dictionary)? options);
 
     // Page Visibility
     // https://w3c.github.io/page-visibility/#extensions-to-the-document-interface
diff --git a/core/dom/Element.cpp b/core/dom/Element.cpp
index 1877eb60..bc2e677b 100644
--- a/core/dom/Element.cpp
+++ b/core/dom/Element.cpp
@@ -156,6 +156,14 @@
 #include "platform/wtf/text/StringBuilder.h"
 #include "platform/wtf/text/TextPosition.h"
 
+// Observer
+#include "base/logging.h"
+#include "core/dom/Observer.h"
+#include "platform/wtf/text/WTFString.h"
+#include "core/dom/NodeList.h"
+#include "bindings/core/v8/BindingSecurity.h"
+#include <iostream>
+
 namespace blink {
 
 namespace {
@@ -281,6 +289,15 @@ Element* Element::CloneElementWithoutAttributesAndChildren() {
   return GetDocument().createElement(TagQName(), kCreatedByCloneNode);
 }
 
+
+const AtomicString Element::nid()
+{
+  AtomicString value = AtomicString::Number(getNid());
+  setAttribute(HTMLNames::nidAttr, value);
+  return value;
+}
+
+
 Attr* Element::DetachAttribute(size_t index) {
   DCHECK(GetElementData());
   const Attribute& attribute = GetElementData()->Attributes().at(index);
@@ -3081,6 +3098,12 @@ void Element::SetInnerHTMLFromString(const String& html,
     ContainerNode* container = this;
     if (auto* template_element = ToHTMLTemplateElementOrNull(*this))
       container = template_element->content();
+    // Set the initiator of all elements created by this method
+    // The container node itself is not necessarily an anchor or a script element
+    const char* anchor_str = "a>";
+    const char* script_str = "script>";
+    if(html.Find(String(anchor_str)) != kNotFound || html.Find(String(script_str)) != kNotFound)
+      BindingSecurity::SetNodeAndChildrenInitiator(&GetDocument(), fragment, true);
     ReplaceChildrenWithFragment(container, fragment, exception_state);
   }
 }
@@ -3136,6 +3159,12 @@ void Element::SetOuterHTMLFromString(const String& html,
   if (exception_state.HadException())
     return;
 
+  // Set the initiator of all elements created by this method
+  // The container node itself is not necessarily an anchor or a script element
+  const char* anchor_str = "a>";
+  const char* script_str = "script>";
+  if(html.Find(String(anchor_str)) != kNotFound || html.Find(String(script_str)) != kNotFound)
+    BindingSecurity::SetNodeAndChildrenInitiator(&GetDocument(), fragment, true);
   parent->ReplaceChild(fragment, this, exception_state);
   Node* node = next ? next->previousSibling() : nullptr;
   if (!exception_state.HadException() && node && node->IsTextNode())
@@ -3257,6 +3286,8 @@ static Element* ContextElementForInsertion(const String& where,
 Element* Element::insertAdjacentElement(const String& where,
                                         Element* new_child,
                                         ExceptionState& exception_state) {
+  if(IsHTMLAnchorElement(new_child)||IsHTMLScriptElement(new_child))
+    BindingSecurity::SetNodeAndChildrenInitiator(&GetDocument(), new_child, true);
   Node* return_value = InsertAdjacent(where, new_child, exception_state);
   return ToElement(return_value);
 }
@@ -3280,6 +3311,10 @@ void Element::insertAdjacentHTML(const String& where,
       exception_state);
   if (!fragment)
     return;
+  const char* anchor_str = "a>";
+  const char* script_str = "script>";
+  if(markup.Find(String(anchor_str)) != kNotFound || markup.Find(String(script_str)) != kNotFound)
+    BindingSecurity::SetNodeAndChildrenInitiator(&GetDocument(), fragment, true);
   InsertAdjacent(where, fragment, exception_state);
 }
 
@@ -4226,6 +4261,7 @@ Node::InsertionNotificationRequest Node::InsertedInto(
   if (insertion_point->isConnected()) {
     SetFlag(kIsConnectedFlag);
     insertion_point->GetDocument().IncrementNodeCount();
+    this->setNid(insertion_point->GetDocument().UniqueNodeCount());
   }
   if (ParentOrShadowHostNode()->IsInShadowTree())
     SetFlag(kIsInShadowTreeFlag);
diff --git a/core/dom/Element.h b/core/dom/Element.h
index 9f845777..278e19c5 100644
--- a/core/dom/Element.h
+++ b/core/dom/Element.h
@@ -39,6 +39,9 @@
 #include "platform/scroll/ScrollTypes.h"
 #include "public/platform/WebFocusType.h"
 
+// Observer
+#include "core/dom/Observer.h"
+
 namespace blink {
 
 class AccessibleNode;
@@ -217,6 +220,11 @@ class CORE_EXPORT Element : public ContainerNode {
                       const AtomicString& value,
                       ExceptionState&);
 
+
+
+  const AtomicString nid() override;
+
+
   const AtomicString& GetIdAttribute() const;
   void SetIdAttribute(const AtomicString&);
 
@@ -1152,6 +1160,8 @@ inline const AtomicString& Element::IdForStyleResolution() const {
   return GetElementData()->IdForStyleResolution();
 }
 
+
+
 inline const AtomicString& Element::GetIdAttribute() const {
   return HasID() ? FastGetAttribute(HTMLNames::idAttr) : g_null_atom;
 }
diff --git a/core/dom/Element.idl b/core/dom/Element.idl
index 6e1aa51a..a9297c9c 100644
--- a/core/dom/Element.idl
+++ b/core/dom/Element.idl
@@ -24,7 +24,6 @@
 enum NativeScrollBehavior { "disable-native-scroll", "perform-before-native-scroll", "perform-after-native-scroll" };
 
 // https://dom.spec.whatwg.org/#interface-element
-
 interface Element : Node {
     readonly attribute DOMString? namespaceURI;
     readonly attribute DOMString? prefix;
@@ -47,10 +46,10 @@ interface Element : Node {
     sequence<DOMString> getAttributeNames();
     DOMString? getAttribute(DOMString name);
     DOMString? getAttributeNS(DOMString? namespaceURI, DOMString localName);
-    [RaisesException, CEReactions, CustomElementCallbacks] void setAttribute(DOMString name, DOMString value);
-    [RaisesException, CEReactions, CustomElementCallbacks] void setAttributeNS(DOMString? namespaceURI, DOMString name, DOMString value);
-    [CEReactions, CustomElementCallbacks] void removeAttribute(DOMString name);
-    [CEReactions, CustomElementCallbacks] void removeAttributeNS(DOMString? namespaceURI, DOMString localName);
+    [RaisesException, CEReactions, CustomElementCallbacks, CheckSecurity=(Caller,WriteSelf)] void setAttribute(DOMString name, DOMString value);
+    [RaisesException, CEReactions, CustomElementCallbacks, CheckSecurity=(Caller,WriteSelf)] void setAttributeNS(DOMString? namespaceURI, DOMString name, DOMString value);
+    [CEReactions, CustomElementCallbacks, CheckSecurity=(Caller,WriteSelf)] void removeAttribute(DOMString name);
+    [CEReactions, CustomElementCallbacks, CheckSecurity=(Caller,WriteSelf)] void removeAttributeNS(DOMString? namespaceURI, DOMString localName);
     boolean hasAttribute(DOMString name);
     boolean hasAttributeNS(DOMString? namespaceURI, DOMString localName);
 
diff --git a/core/dom/MockScriptElementBase.h b/core/dom/MockScriptElementBase.h
index e0bcbdb4..cb586ced 100644
--- a/core/dom/MockScriptElementBase.h
+++ b/core/dom/MockScriptElementBase.h
@@ -53,6 +53,7 @@ class MockScriptElementBase
   MOCK_METHOD1(SetScriptElementForBinding,
                void(HTMLScriptElementOrSVGScriptElement&));
   MOCK_CONST_METHOD0(Loader, ScriptLoader*());
+  MOCK_CONST_METHOD0(isHTMLScript, bool());
 
   virtual void Trace(blink::Visitor* visitor) {
     ScriptElementBase::Trace(visitor);
diff --git a/core/dom/Node.cpp b/core/dom/Node.cpp
index 29021fe6..561bb3fb 100644
--- a/core/dom/Node.cpp
+++ b/core/dom/Node.cpp
@@ -135,8 +135,10 @@ using namespace HTMLNames;
 
 struct SameSizeAsNode : EventTarget {
   uint32_t node_flags_;
-  Member<void*> willbe_member_[4];
+  Member<void*> willbe_member_[5];
   void* pointer_;
+  int nid_;
+  bool was_clicked_;
 };
 
 NodeRenderingData::NodeRenderingData(
@@ -309,7 +311,9 @@ Node::Node(TreeScope* tree_scope, ConstructionType type)
       parent_or_shadow_host_node_(nullptr),
       tree_scope_(tree_scope),
       previous_(nullptr),
-      next_(nullptr) {
+      next_(nullptr),
+      nid_(0),
+      was_clicked_(false) {
   DCHECK(tree_scope_ || type == kCreateDocument || type == kCreateShadowRoot);
 #if !defined(NDEBUG) || (defined(DUMP_NODE_STATISTICS) && DUMP_NODE_STATISTICS)
   TrackForDebugging();
@@ -433,6 +437,7 @@ Node* Node::getRootNode(const GetRootNodeOptions& options) const {
                                                        : &TreeRoot();
 }
 
+
 Node* Node::insertBefore(Node* new_child,
                          Node* ref_child,
                          ExceptionState& exception_state) {
diff --git a/core/dom/Node.h b/core/dom/Node.h
index b8ff7897..78f944dc 100644
--- a/core/dom/Node.h
+++ b/core/dom/Node.h
@@ -37,6 +37,9 @@
 #include "platform/geometry/LayoutRect.h"
 #include "public/platform/WebFocusType.h"
 
+// Observer
+#include "core/dom/Observer.h"
+
 // This needs to be here because Element.cpp also depends on it.
 #define DUMP_NODE_STATISTICS 0
 
@@ -246,6 +249,19 @@ class CORE_EXPORT Node : public EventTarget {
 
   const KURL& baseURI() const;
 
+  virtual const AtomicString observerLog() { return g_null_atom; }
+  virtual const AtomicString initiator() { return g_null_atom; }
+  virtual const AtomicString nid() { return g_null_atom; }
+
+  // returns 0 if is created by first party; otherwise, returns the ID(s) of
+  // third-party script(s) that created this element.
+  int getNid() const { return nid_; }
+  void setNid(int nid) { nid_ = nid; }
+  void setNid(String nid) { nid_ = nid.ToInt(); }
+  bool wasClicked() const { return was_clicked_; }
+  void setWasClicked(bool flag) { was_clicked_ = flag; }
+
+
   Node* insertBefore(Node* new_child, Node* ref_child, ExceptionState&);
   Node* insertBefore(Node* new_child, Node* ref_child);
   Node* replaceChild(Node* new_child, Node* old_child, ExceptionState&);
@@ -842,6 +858,7 @@ class CORE_EXPORT Node : public EventTarget {
 
   virtual void TraceWrappers(const ScriptWrappableVisitor*) const;
 
+
  private:
   enum NodeFlags {
     kHasRareDataFlag = 1,
@@ -1002,6 +1019,8 @@ class CORE_EXPORT Node : public EventTarget {
     NodeRenderingData* node_layout_data_;
     NodeRareDataBase* rare_data_;
   } data_;
+  int nid_;
+  bool was_clicked_;
 };
 
 inline void Node::SetParentOrShadowHostNode(ContainerNode* parent) {
diff --git a/core/dom/Node.idl b/core/dom/Node.idl
index 78937d3f..cb4f3445 100644
--- a/core/dom/Node.idl
+++ b/core/dom/Node.idl
@@ -19,7 +19,6 @@
  */
 
 // https://dom.spec.whatwg.org/#interface-node
-
 interface Node : EventTarget {
     const unsigned short ELEMENT_NODE = 1;
     const unsigned short ATTRIBUTE_NODE = 2;
@@ -38,6 +37,8 @@ interface Node : EventTarget {
 
     readonly attribute USVString baseURI;
 
+    readonly attribute DOMString nid;
+
     [Measure] readonly attribute boolean isConnected;
     [PerWorldBindings] readonly attribute Document? ownerDocument;
     [PerWorldBindings] readonly attribute Node? parentNode;
diff --git a/core/dom/Observer.cpp b/core/dom/Observer.cpp
new file mode 100644
index 00000000..797c7dfb
--- /dev/null
+++ b/core/dom/Observer.cpp
@@ -0,0 +1,112 @@
+#include "config.h"
+#include "base/environment.h"
+#include "core/dom/Observer.h"
+#include "platform/wtf/text/StringHash.h"
+#include "platform/wtf/Vector.h"
+#include "platform/json/JSONValues.h"
+
+namespace blink {
+
+bool DocumentInfoManager::setScriptID2URL(int scriptID, const String& sourceURL)
+{
+    HashMap<int, String>::AddResult addResult = m_scriptID2URL.Set(scriptID, sourceURL);
+    return addResult.is_new_entry;
+}
+
+bool DocumentInfoManager::setScriptID2ParentScriptID(int scriptID, const String& parentScriptID)
+{
+    HashMap<int, String>::AddResult addResult = m_scriptID2ParentScriptID.Set(scriptID, parentScriptID);
+    return addResult.is_new_entry;
+}
+
+const String& DocumentInfoManager::getScriptID2URL(int scriptID)
+{
+    HashMap<int, String>::iterator it = m_scriptID2URL.find(scriptID);
+    if (it == m_scriptID2URL.end())
+        return m_emptyString;
+    return it->value;
+}
+
+const String DocumentInfoManager::scriptIDMapString()
+{
+  String result = "{\"scriptID2URL\": {";
+  int count = 0;
+  for (HashMap<int, String>::iterator it = m_scriptID2URL.begin();
+      it != m_scriptID2URL.end(); ++it) {
+    result.append("\"");
+    result.append(String::Number(it->key));
+    result.append("\":");
+    result.append(JSONValue::QuoteString(it->value));
+    result.append(",");
+    count++;
+  }
+  int length = result.length();
+  if (count > 0) {
+    result = result.replace(length-1, 1, "}");
+  }
+  else {
+    result.append("}");
+  }
+  result.append(", \"scriptID2ParentScriptID\": {");
+  count = 0;
+  for (HashMap<int, String>::iterator it = m_scriptID2ParentScriptID.begin();
+      it != m_scriptID2ParentScriptID.end(); ++it) {
+    result.append("\"");
+    result.append(String::Number(it->key));
+    result.append("\":\"");
+    result.append(it->value);
+    result.append("\",");
+    count++;
+  }
+  length = result.length();
+  if (count > 0) {
+    result = result.replace(length-1, 1, "}");
+  }
+  else {
+    result.append("}");
+  }
+  result.append("}");
+
+  return result;
+}
+
+void DocumentInfoManager::appendAPILog(const String& log)
+{
+    if (m_APILogs.length() > 0) {
+      m_APILogs.append(",");
+    }
+    m_APILogs.append(log);
+}
+
+const String DocumentInfoManager::getAPILogs()
+{
+  m_currentEventTarget = -1;
+  return "["+ m_APILogs + "]";
+}
+
+void ObserverLogManager::appendObserverLog(const String& log)
+{
+    if (m_logs.length() > 0) {
+      m_logs.append(",");
+    }
+    m_logs.append(log);
+}
+
+const String ObserverLogManager::getObserverLogs()
+{
+  return "["+ m_logs + "]";
+}
+
+
+bool IsObserverEnabled() {
+    static bool initialized = false;
+    static bool enabled = false;
+    if (initialized)
+        return enabled;
+    std::unique_ptr<base::Environment> env(base::Environment::Create());
+    enabled = env->HasVar("ENABLE_OBSERVER");
+    initialized = true;
+    return enabled;
+}
+
+}
diff --git a/core/dom/Observer.h b/core/dom/Observer.h
new file mode 100644
index 00000000..66e0e2e5
--- /dev/null
+++ b/core/dom/Observer.h
@@ -0,0 +1,66 @@
+#ifndef Observer_H
+#define Observer_H
+
+#include "platform/heap/Handle.h"
+#include "platform/wtf/HashMap.h"
+#include "platform/wtf/text/WTFString.h"
+
+namespace blink {
+
+
+enum DOMAccessRequest {
+    ATTEMPT_TO_EXECUTE       = 1, // Attempting to execute methods
+    ATTEMPT_TO_WRITE         = 2, // Attempting to write attributes
+    ATTEMPT_TO_READ          = 4, // Attempting to read attributes
+    ATTEMPT_TO_WRITE_EXECUTE = ATTEMPT_TO_WRITE | ATTEMPT_TO_EXECUTE, // Attempting to write attributes & execute methods
+};
+
+
+class DocumentInfoManager {
+public:
+    DocumentInfoManager()
+      : m_currentEventTarget(0)
+    {}
+    
+    ~DocumentInfoManager() {};
+
+    bool setScriptID2URL(int, const String&);
+    bool setScriptID2ParentScriptID(int, const String&);
+    const String& getScriptID2URL(int);
+    const String scriptIDMapString();
+    int getCurrentEventTarget() { return m_currentEventTarget; }
+    void setCurrentEventTarget(int nid) { m_currentEventTarget = nid; }
+    const AtomicString& getCurrentEventType() { return m_currentEventType; }
+    void setCurrentEventType(const AtomicString& type) { m_currentEventType = type; }
+    void appendAPILog(const String&);
+    const String getAPILogs();
+    void clearAPILogs() { m_APILogs = ""; }
+
+private:
+    HashMap<int, String> m_scriptID2URL; // scriptID -> sourceURL
+    HashMap<int, String> m_scriptID2ParentScriptID; // scriptID -> parentScriptID
+    String m_emptyString;
+    int m_currentEventTarget; // nid of Node that is the current EventTarget
+    AtomicString m_currentEventType;
+    String m_APILogs;
+};
+
+class ObserverLogManager {
+public:
+    ObserverLogManager() {};
+    
+    ~ObserverLogManager() {};
+
+    void appendObserverLog(const String&);
+    const String getObserverLogs();
+
+private:
+    String m_logs;
+};
+
+
+bool IsObserverEnabled();
+}
+
+#endif // Observer_H
+
diff --git a/core/dom/ScriptElementBase.h b/core/dom/ScriptElementBase.h
index 30d75fd3..2c803ec5 100644
--- a/core/dom/ScriptElementBase.h
+++ b/core/dom/ScriptElementBase.h
@@ -68,6 +68,7 @@ class CORE_EXPORT ScriptElementBase : public GarbageCollectedMixin {
 
   virtual ScriptLoader* Loader() const = 0;
 
+  virtual bool IsHTMLScript() const = 0;
  protected:
   ScriptLoader* InitializeScriptLoader(bool parser_inserted,
                                        bool already_started,
diff --git a/core/dom/ScriptLoader.cpp b/core/dom/ScriptLoader.cpp
index 69ab108f..e3c51a80 100644
--- a/core/dom/ScriptLoader.cpp
+++ b/core/dom/ScriptLoader.cpp
@@ -61,6 +61,11 @@
 #include "platform/wtf/text/StringBuilder.h"
 #include "platform/wtf/text/StringHash.h"
 
+// Observer
+#include "base/logging.h"
+#include "core/dom/Observer.h"
+#include "core/html/HTMLScriptElement.h"
+
 namespace blink {
 
 ScriptLoader::ScriptLoader(ScriptElementBase* element,
@@ -73,6 +78,7 @@ ScriptLoader::ScriptLoader(ScriptElementBase* element,
       will_be_parser_executed_(false),
       will_execute_when_document_finished_parsing_(false),
       created_during_document_write_(created_during_document_write),
+      m_isInsertedScript(false),
       async_exec_type_(ScriptRunner::kNone) {
   // https://html.spec.whatwg.org/#already-started
   // "The cloning steps for script elements must set the "already started"
@@ -264,6 +270,9 @@ bool ScriptLoader::PrepareScript(const TextPosition& script_start_position,
     was_parser_inserted = false;
   }
 
+  if ((!was_parser_inserted || created_during_document_write_) && !element_->HasSourceAttribute())
+      m_isInsertedScript = true;
+
   // 3. "If was-parser-inserted is true and the element does not have an
   //     async attribute, then set the element's "non-blocking" flag to true."
   if (was_parser_inserted && !element_->AsyncAttributeValue())
@@ -674,9 +683,14 @@ bool ScriptLoader::PrepareScript(const TextPosition& script_start_position,
   // Note: this block is also duplicated in
   // HTMLParserScriptRunner::processScriptElementInternal().
   // TODO(hiroshige): Merge the duplicated code.
-  KURL script_url = (!element_document.IsInDocumentWrite() && parser_inserted_)
-                        ? element_document.Url()
-                        : KURL();
+  
+  // Set scriptURL to m_insertingScriptURL to enforce access control in BindingSecurity
+  KURL script_url = (m_isInsertedScript && !m_insertingScriptURL.IsEmpty())
+                       ? KURL(m_insertingScriptURL)
+                       : ((!element_document.IsInDocumentWrite() && parser_inserted_)
+                           ? element_document.Url()
+                           : KURL());
+
   ExecuteScriptBlock(TakePendingScript(), script_url);
   return true;
 }
@@ -806,6 +820,25 @@ ScriptLoader::ExecuteScriptResult ScriptLoader::DoExecuteScript(
   //    2. "Run the module script given by the script's script."
   script->RunScript(frame, element_->GetDocument().GetSecurityOrigin());
 
+  if (element_->IsHTMLScript()) {
+    HTMLScriptElement* script_element = static_cast<HTMLScriptElement*>(element_.Get());
+    int scriptID = frame->GetScriptController().scriptID();
+    script_element->setScriptID(scriptID);
+    String parentScriptID = script_element->getParentScriptID();
+    String initiator = script_element->getInitiator();
+    // Set parentScriptID to initiator if initiator is positive and parentScriptID is not set
+    if (initiator.length() > 0 && initiator != parentScriptID) {
+      script_element->setParentScriptID(initiator);
+      parentScriptID = initiator;
+      element_document->setScriptID2ParentScriptID(scriptID, initiator);
+    }
+    else {
+      element_document->setScriptID2ParentScriptID(scriptID, parentScriptID);
+    }
+    if (initiator.length() == 0)
+      script_element->setInitiator(parentScriptID);
+  }
+
   // 6. "Set the script element's node document's currentScript attribute
   //     to old script element."
   context_document->PopCurrentScript(current_script);
diff --git a/core/dom/ScriptLoader.h b/core/dom/ScriptLoader.h
index 44e0fd7a..b7401d2f 100644
--- a/core/dom/ScriptLoader.h
+++ b/core/dom/ScriptLoader.h
@@ -113,6 +113,7 @@ class CORE_EXPORT ScriptLoader : public GarbageCollectedFinalized<ScriptLoader>,
   bool AlreadyStarted() const { return already_started_; }
   bool IsNonBlocking() const { return non_blocking_; }
   ScriptType GetScriptType() const { return script_type_; }
+  void setInsertingScriptURL(String sourceURL) { m_insertingScriptURL = sourceURL; }
 
   // Helper functions used by our parent classes.
   void DidNotifySubtreeInsertionsToDocument();
@@ -177,6 +178,8 @@ class CORE_EXPORT ScriptLoader : public GarbageCollectedFinalized<ScriptLoader>,
   Member<ScriptElementBase> element_;
   WTF::OrdinalNumber start_line_number_;
 
+  String m_insertingScriptURL;
+
   // https://html.spec.whatwg.org/#script-processing-model
   // "A script element has several associated pieces of state.":
 
@@ -213,6 +216,8 @@ class CORE_EXPORT ScriptLoader : public GarbageCollectedFinalized<ScriptLoader>,
 
   const bool created_during_document_write_;
 
+  bool m_isInsertedScript;
+
   ScriptRunner::AsyncExecutionType async_exec_type_;
 
   // A PendingScript is first created in PrepareScript() and stored in
diff --git a/core/dom/events/Event.cpp b/core/dom/events/Event.cpp
index 670fc7bd..37564dfb 100644
--- a/core/dom/events/Event.cpp
+++ b/core/dom/events/Event.cpp
@@ -227,6 +227,10 @@ bool Event::IsBeforeUnloadEvent() const {
   return false;
 }
 
+bool Event::IsAnimationEvent() const {
+  return false;
+}
+
 void Event::preventDefault() {
   if (handling_passive_ != PassiveMode::kNotPassive &&
       handling_passive_ != PassiveMode::kNotPassiveDefault) {
diff --git a/core/dom/events/Event.h b/core/dom/events/Event.h
index 47cdc11f..67349206 100644
--- a/core/dom/events/Event.h
+++ b/core/dom/events/Event.h
@@ -169,6 +169,7 @@ class CORE_EXPORT Event : public ScriptWrappable {
   virtual bool IsRelatedEvent() const;
   virtual bool IsPointerEvent() const;
   virtual bool IsInputEvent() const;
+  virtual bool IsAnimationEvent() const;
 
   // Drag events are a subset of mouse events.
   virtual bool IsDragEvent() const;
diff --git a/core/dom/events/EventTarget.cpp b/core/dom/events/EventTarget.cpp
index b2552438..fab1bb78 100644
--- a/core/dom/events/EventTarget.cpp
+++ b/core/dom/events/EventTarget.cpp
@@ -60,6 +60,10 @@
 #include "platform/wtf/Vector.h"
 #include "public/web/WebSettings.h"
 
+// Observer
+#include "base/logging.h"
+#include "core/dom/Observer.h"
+
 namespace blink {
 namespace {
 
@@ -634,6 +638,18 @@ DispatchEventResult EventTarget::FireEventListeners(Event* event) {
   if (!d)
     return DispatchEventResult::kNotCanceled;
 
+  Node *target_node = event->target()->ToNode();
+  if (event->type() == "click") {
+    // Only click once
+    if (target_node->wasClicked())
+      //return DispatchEventResult::kNotCanceled;
+      return DispatchEventResult::kCanceledByEventHandler;
+    else {
+      target_node->setWasClicked(true);
+    }
+  }
+  if (target_node && !event->IsAnimationEvent())
+    target_node->GetDocument().setCurrentFiredEvent(event);
   EventListenerVector* legacy_listeners_vector = nullptr;
   AtomicString legacy_type_name = LegacyType(event);
   if (!legacy_type_name.IsEmpty())
diff --git a/core/events/AnimationEvent.cpp b/core/events/AnimationEvent.cpp
index 4a3ac5bd..33963361 100644
--- a/core/events/AnimationEvent.cpp
+++ b/core/events/AnimationEvent.cpp
@@ -60,4 +60,9 @@ void AnimationEvent::Trace(blink::Visitor* visitor) {
   Event::Trace(visitor);
 }
 
+bool AnimationEvent::IsAnimationEvent() const {
+  return true;
+}
+
+
 }  // namespace blink
diff --git a/core/events/AnimationEvent.h b/core/events/AnimationEvent.h
index df85a861..d1535b43 100644
--- a/core/events/AnimationEvent.h
+++ b/core/events/AnimationEvent.h
@@ -53,6 +53,8 @@ class AnimationEvent final : public Event {
 
   const AtomicString& InterfaceName() const override;
 
+  bool IsAnimationEvent() const override;
+
   virtual void Trace(blink::Visitor*);
 
  private:
diff --git a/core/frame/DOMWindow.cpp b/core/frame/DOMWindow.cpp
index 01e63ad2..823a3f21 100644
--- a/core/frame/DOMWindow.cpp
+++ b/core/frame/DOMWindow.cpp
@@ -30,6 +30,11 @@
 #include "platform/weborigin/SecurityOrigin.h"
 #include "platform/weborigin/Suborigin.h"
 
+// Observer
+#include "base/logging.h"
+#include "core/dom/Observer.h"
+#include "bindings/core/v8/BindingSecurity.h"
+
 namespace blink {
 
 DOMWindow::DOMWindow(Frame& frame)
@@ -376,6 +381,11 @@ void DOMWindow::close(LocalDOMWindow* incumbent_window) {
       return;
   }
 
+  BindingSecurity::LogAPIAccess(active_document, "DOMWindow::close()", active_document->Url().GetString());
+  if (active_document->isSensitiveAPIsDisabled()) {
+    return;
+  }
+
   Settings* settings = GetFrame()->GetSettings();
   bool allow_scripts_to_close_windows =
       settings && settings->GetAllowScriptsToCloseWindows();
diff --git a/core/frame/LocalDOMWindow.cpp b/core/frame/LocalDOMWindow.cpp
index c3982f5d..c772792d 100644
--- a/core/frame/LocalDOMWindow.cpp
+++ b/core/frame/LocalDOMWindow.cpp
@@ -98,6 +98,11 @@
 #include "public/platform/WebScreenInfo.h"
 #include "public/platform/site_engagement.mojom-blink.h"
 
+// Observer
+#include "base/logging.h"
+#include "core/dom/Observer.h"
+#include "bindings/core/v8/BindingSecurity.h"
+
 namespace blink {
 
 // Timeout for link preloads to be used after window.onload
@@ -745,6 +750,10 @@ void LocalDOMWindow::alert(ScriptState* script_state, const String& message) {
     return;
   }
 
+  if (IsObserverEnabled() || document()->isSensitiveAPIsDisabled()) {
+    return;
+  }
+
   switch (document()->GetEngagementLevel()) {
     case mojom::blink::EngagementLevel::NONE:
       UseCounter::Count(document(), WebFeature::kAlertEngagementNone);
@@ -795,6 +804,10 @@ bool LocalDOMWindow::confirm(ScriptState* script_state, const String& message) {
     return false;
   }
 
+  if (IsObserverEnabled() || document()->isSensitiveAPIsDisabled()) {
+    return false;
+  }
+
   switch (document()->GetEngagementLevel()) {
     case mojom::blink::EngagementLevel::NONE:
       UseCounter::Count(document(), WebFeature::kConfirmEngagementNone);
@@ -847,6 +860,10 @@ String LocalDOMWindow::prompt(ScriptState* script_state,
     return String();
   }
 
+  if (IsObserverEnabled() || document()->isSensitiveAPIsDisabled()) {
+    return String();
+  }
+
   switch (document()->GetEngagementLevel()) {
     case mojom::blink::EngagementLevel::NONE:
       UseCounter::Count(document(), WebFeature::kPromptEngagementNone);
@@ -1553,6 +1570,11 @@ DOMWindow* LocalDOMWindow::open(const String& url_string,
   if (!first_frame)
     return nullptr;
 
+  BindingSecurity::LogAPIAccess(active_document, "LocalDOMWindow::open()", url_string);
+  if (active_document->isSensitiveAPIsDisabled()) {
+    return nullptr;
+  }
+
   UseCounter::Count(*active_document, WebFeature::kDOMWindowOpen);
   if (!window_features_string.IsEmpty())
     UseCounter::Count(*active_document, WebFeature::kDOMWindowOpenFeatures);
diff --git a/core/frame/Location.cpp b/core/frame/Location.cpp
index aa1971ff..954706e4 100644
--- a/core/frame/Location.cpp
+++ b/core/frame/Location.cpp
@@ -43,6 +43,11 @@
 #include "platform/weborigin/KURL.h"
 #include "platform/weborigin/SecurityOrigin.h"
 
+// Observer
+#include "base/logging.h"
+#include "core/dom/Observer.h"
+#include "bindings/core/v8/BindingSecurity.h"
+
 namespace blink {
 
 Location::Location(DOMWindow* dom_window) : dom_window_(dom_window) {}
@@ -272,6 +277,12 @@ void Location::SetLocation(const String& url,
   if (completed_url.IsNull())
     return;
 
+  Document* active_document = current_window->document();
+  BindingSecurity::LogAPIAccess(active_document, "Location::SetLocation()", completed_url.GetString());
+  if (active_document->isSensitiveAPIsDisabled()) {
+    return;
+  }
+
   if (!current_window->GetFrame()->CanNavigate(*dom_window_->GetFrame(),
                                                completed_url)) {
     if (exception_state) {
diff --git a/core/frame/csp/ContentSecurityPolicy.cpp b/core/frame/csp/ContentSecurityPolicy.cpp
index 59c4ab87..28c4a52f 100644
--- a/core/frame/csp/ContentSecurityPolicy.cpp
+++ b/core/frame/csp/ContentSecurityPolicy.cpp
@@ -265,16 +265,18 @@ void ContentSecurityPolicy::CopyPluginTypesFrom(
   }
 }
 
+
 void ContentSecurityPolicy::DidReceiveHeaders(
     const ContentSecurityPolicyResponseHeaders& headers) {
   if (headers.ShouldParseWasmEval()) {
     supports_wasm_eval_ = true;
   }
-  if (!headers.ContentSecurityPolicy().IsEmpty())
+  if (!headers.ContentSecurityPolicy().IsEmpty()) 
     AddAndReportPolicyFromHeaderValue(headers.ContentSecurityPolicy(),
                                       kContentSecurityPolicyHeaderTypeEnforce,
                                       kContentSecurityPolicyHeaderSourceHTTP);
-  if (!headers.ContentSecurityPolicyReportOnly().IsEmpty())
+
+  if (!headers.ContentSecurityPolicyReportOnly().IsEmpty()) 
     AddAndReportPolicyFromHeaderValue(headers.ContentSecurityPolicyReportOnly(),
                                       kContentSecurityPolicyHeaderTypeReport,
                                       kContentSecurityPolicyHeaderSourceHTTP);
@@ -285,7 +287,7 @@ void ContentSecurityPolicy::DidReceiveHeader(
     ContentSecurityPolicyHeaderType type,
     ContentSecurityPolicyHeaderSource source) {
   AddAndReportPolicyFromHeaderValue(header, type, source);
-
+  
   // This might be called after we've been bound to an execution context. For
   // example, a <meta> element might be injected after page load.
   if (execution_context_)
diff --git a/core/html/HTMLAnchorElement.cpp b/core/html/HTMLAnchorElement.cpp
index 6b17acc5..96529292 100644
--- a/core/html/HTMLAnchorElement.cpp
+++ b/core/html/HTMLAnchorElement.cpp
@@ -43,6 +43,12 @@
 #include "platform/network/NetworkHints.h"
 #include "platform/weborigin/SecurityPolicy.h"
 
+// Observer
+#include "base/logging.h"
+#include "core/dom/Observer.h"
+#include "bindings/core/v8/BindingSecurity.h"
+#include "core/html/HTMLScriptElement.h"
+
 namespace blink {
 
 using namespace HTMLNames;
@@ -86,6 +92,45 @@ void HTMLAnchorElement::DispatchFocusEvent(
                                   source_capabilities);
 }
 
+
+const AtomicString HTMLAnchorElement::initiator() {
+  AtomicString value = AtomicString(getInitiator());
+  setAttribute(HTMLNames::initiatorAttr, value);
+  return value;
+}
+  
+const AtomicString HTMLAnchorElement::observerLog()
+{
+  AtomicString value = AtomicString(m_observerLogManager.getObserverLogs());
+  setAttribute(HTMLNames::observerlogAttr, value);
+  return value;
+}
+
+
+void HTMLAnchorElement::setChildrenInitiator(String initiator) {
+  setInitiator(initiator);
+  NodeList* children = childNodes();
+  int length = children->length();
+  for (int i = 0; i < length; ++i) {
+    Node* child = children->item(i);
+    if (child->IsElementNode()) {
+      if(IsHTMLAnchorElement(child)||IsHTMLScriptElement(child)) {
+        String childInitiator;
+        if(IsHTMLAnchorElement(child)) 
+          childInitiator = ToHTMLAnchorElement(child)->getInitiator();
+        else
+          childInitiator = ToHTMLScriptElement(child)->getInitiator();
+        if (childInitiator != initiator) {
+          if(IsHTMLAnchorElement(child)) 
+            ToHTMLAnchorElement(child)->setChildrenInitiator(initiator);
+          else
+            ToHTMLScriptElement(child)->setChildrenInitiator(initiator);
+        }
+      }
+    }
+  }
+}
+
 void HTMLAnchorElement::DispatchBlurEvent(
     Element* new_focused_element,
     WebFocusType type,
@@ -158,6 +203,21 @@ static void AppendServerMapMousePosition(StringBuilder& url, Event* event) {
 
 void HTMLAnchorElement::DefaultEventHandler(Event* event) {
   if (IsLink()) {
+    StringBuilder url;
+    url.Append(StripLeadingAndTrailingHTMLSpaces(FastGetAttribute(hrefAttr)));
+    AppendServerMapMousePosition(url, event);
+    KURL completed_url = GetDocument().CompleteURL(url.ToString());
+
+    Document* active_document = &GetDocument();
+    if ((IsFocused() && IsEnterKeyKeydownEvent(event) && IsLiveLink()) || (IsLinkClick(event) && IsLiveLink())) {
+      active_document->setCurrentFiredEvent(event);
+      this->setWasClicked(true);
+      BindingSecurity::LogAPIAccess(active_document, "HTMLAnchorElement", completed_url.GetString());
+    }
+    if (active_document->isSensitiveAPIsDisabled()) {
+      return;
+    }
+
     if (IsFocused() && IsEnterKeyKeydownEvent(event) && IsLiveLink()) {
       event->SetDefaultHandled();
       DispatchSimulatedClick(event);
@@ -353,6 +413,7 @@ void HTMLAnchorElement::HandleClick(Event* event) {
   AppendServerMapMousePosition(url, event);
   KURL completed_url = GetDocument().CompleteURL(url.ToString());
 
+
   // Schedule the ping before the frame load. Prerender in Chrome may kill the
   // renderer as soon as the navigation is sent out.
   SendPings(completed_url);
diff --git a/core/html/HTMLAnchorElement.h b/core/html/HTMLAnchorElement.h
index 9fbd8293..6c17bf97 100644
--- a/core/html/HTMLAnchorElement.h
+++ b/core/html/HTMLAnchorElement.h
@@ -88,6 +88,17 @@ class CORE_EXPORT HTMLAnchorElement : public HTMLElement, public DOMURLUtils {
 
   void SendPings(const KURL& destination_url) const;
 
+
+  const AtomicString initiator() override;
+  String getInitiator() const { return initiator_; }
+  void setInitiator(String initiator) { initiator_ = initiator; }
+  void setChildrenInitiator(String initiator);
+  
+  ObserverLogManager m_observerLogManager;
+  void appendObserverLog(const String& log) { m_observerLogManager.appendObserverLog(log); }
+  const AtomicString observerLog() override;
+
+
  protected:
   HTMLAnchorElement(const QualifiedName&, Document&);
 
@@ -123,6 +134,8 @@ class CORE_EXPORT HTMLAnchorElement : public HTMLElement, public DOMURLUtils {
   unsigned link_relations_ : 31;
   unsigned was_focused_by_mouse_ : 1;
   mutable LinkHash cached_visited_link_hash_;
+  
+  String initiator_;
 };
 
 inline LinkHash HTMLAnchorElement::VisitedLinkHash() const {
diff --git a/core/html/HTMLAnchorElement.idl b/core/html/HTMLAnchorElement.idl
index 1b736f46..ab8bc4a2 100644
--- a/core/html/HTMLAnchorElement.idl
+++ b/core/html/HTMLAnchorElement.idl
@@ -19,16 +19,20 @@
  */
 
 // https://html.spec.whatwg.org/#the-a-element
-
-interface HTMLAnchorElement : HTMLElement {
+[
+    CheckSecurity=Caller
+] interface HTMLAnchorElement : HTMLElement {
     [CEReactions, Reflect] attribute DOMString target;
     [CEReactions, Reflect] attribute DOMString download;
     // FIXME: ping should be a DOMTokenList.
     [CEReactions, Reflect] attribute DOMString ping;
     [CEReactions, Reflect] attribute DOMString rel;
     // FIXME: readonly attribute DOMTokenList relList;
-    [CEReactions, Reflect] attribute DOMString hreflang;
+    [CEReactions, Reflect, CheckSecurity=(Caller,WriteSelf)] attribute DOMString hreflang;
     [CEReactions, Reflect] attribute DOMString type;
+    
+    readonly attribute DOMString initiator;
+    readonly attribute DOMString observerLog;
     [CEReactions, Reflect, ReflectOnly=("","no-referrer","origin","no-referrer-when-downgrade","origin-when-cross-origin","unsafe-url"), ReflectMissing="", ReflectInvalid=""] attribute DOMString referrerPolicy;
 
     [CEReactions, ImplementedAs=textContent] attribute DOMString text;
diff --git a/core/html/HTMLAttributeNames.json5 b/core/html/HTMLAttributeNames.json5
index fe5742ed..77732752 100644
--- a/core/html/HTMLAttributeNames.json5
+++ b/core/html/HTMLAttributeNames.json5
@@ -19,6 +19,7 @@
     "allowfullscreen",
     "allowpaymentrequest",
     "alt",
+    "apilog",
     "archive",
     "aria-activedescendant",
     "aria-atomic",
@@ -145,6 +146,7 @@
     "http-equiv",
     "id",
     "incremental",
+    "initiator",
     "inert",
     "inputmode",
     "integrity",
@@ -175,6 +177,7 @@
     "multiple",
     "muted",
     "name",
+    "nid",
     "nohref",
     "nomodule",
     "nonce",
@@ -183,6 +186,7 @@
     "novalidate",
     "nowrap",
     "object",
+    "observerlog",
     "onabort",
     "onafterprint",
     "onanimationstart",
@@ -296,6 +300,8 @@
     "onwheel",
     "open",
     "optimum",
+    "parentscriptid",
+    "parentsrc",
     "pattern",
     "placeholder",
     "ping",
@@ -315,6 +321,8 @@
     "sandbox",
     "scheme",
     "scope",
+    "scriptid",
+    "scriptidmap",
     "scrollamount",
     "scrolldelay",
     "scrolling",
diff --git a/core/html/HTMLDataElement.idl b/core/html/HTMLDataElement.idl
index 6f65099d..26c4867c 100644
--- a/core/html/HTMLDataElement.idl
+++ b/core/html/HTMLDataElement.idl
@@ -4,7 +4,7 @@
 
 // https://html.spec.whatwg.org/multipage/text-level-semantics.html#the-data-element
 
-[HTMLConstructor]
+[HTMLConstructor] 
 interface HTMLDataElement : HTMLElement {
     [CEReactions, Reflect] attribute DOMString value;
-};
\ No newline at end of file
+};
diff --git a/core/html/HTMLDivElement.idl b/core/html/HTMLDivElement.idl
index 2eb12158..35d64ee8 100644
--- a/core/html/HTMLDivElement.idl
+++ b/core/html/HTMLDivElement.idl
@@ -18,7 +18,7 @@
  */
 
 // https://html.spec.whatwg.org/#the-div-element
-[HTMLConstructor]
+[HTMLConstructor] 
 interface HTMLDivElement : HTMLElement {
     // obsolete members
     // https://html.spec.whatwg.org/#HTMLDivElement-partial
diff --git a/core/html/HTMLElement.idl b/core/html/HTMLElement.idl
index 3e2e9989..1c244a34 100644
--- a/core/html/HTMLElement.idl
+++ b/core/html/HTMLElement.idl
@@ -19,8 +19,9 @@
  */
 
 // https://html.spec.whatwg.org/#htmlelement
-[HTMLConstructor]
-interface HTMLElement : Element {
+[
+    HTMLConstructor
+] interface HTMLElement : Element {
     // metadata attributes
     [CEReactions, Reflect] attribute DOMString title;
     [CEReactions, Reflect] attribute DOMString lang;
diff --git a/core/html/HTMLParagraphElement.idl b/core/html/HTMLParagraphElement.idl
index 48ca805f..0632211d 100644
--- a/core/html/HTMLParagraphElement.idl
+++ b/core/html/HTMLParagraphElement.idl
@@ -18,7 +18,7 @@
  */
 
 // https://html.spec.whatwg.org/#the-p-element
-[HTMLConstructor]
+[HTMLConstructor] 
 interface HTMLParagraphElement : HTMLElement {
     // obsolete members
     // https://html.spec.whatwg.org/#HTMLParagraphElement-partial
diff --git a/core/html/HTMLScriptElement.cpp b/core/html/HTMLScriptElement.cpp
index 88db8426..9755e9df 100644
--- a/core/html/HTMLScriptElement.cpp
+++ b/core/html/HTMLScriptElement.cpp
@@ -36,6 +36,11 @@
 #include "core/frame/csp/ContentSecurityPolicy.h"
 #include "core/html_names.h"
 
+// Observer
+#include "bindings/core/v8/BindingSecurity.h"
+#include "bindings/core/v8/ScriptCallStackFactory.h"
+#include "core/html/HTMLAnchorElement.h"
+
 namespace blink {
 
 using namespace HTMLNames;
@@ -45,9 +50,31 @@ inline HTMLScriptElement::HTMLScriptElement(Document& document,
                                             bool already_started,
                                             bool created_during_document_write)
     : HTMLElement(scriptTag, document),
+      //m_parentScriptID(0),
+      m_scriptID(0),
       loader_(InitializeScriptLoader(was_inserted_by_parser,
                                      already_started,
-                                     created_during_document_write)) {}
+                                     created_during_document_write)) {
+
+  if (!was_inserted_by_parser || created_during_document_write) {
+    const v8::Local<v8::StackFrame> &currentCallFrame = getBottomFrame(maxCallStackSizeToCapture);
+    //const v8::Local<v8::StackFrame> & currentCallFrame = getTopFrame(maxCallStackSizeToCapture);
+    if (!currentCallFrame.IsEmpty()) {
+      String source = toCoreStringOrDefault(currentCallFrame->GetScriptNameOrSourceURL(), "<anonymous>");
+      const KURL sourceURL = KURL(source);
+      if (BindingSecurity::IsChromeURL(sourceURL.Protocol()) or BindingSecurity::IsExtensionURL(sourceURL.Protocol()))
+        return;
+      int scriptID = currentCallFrame->GetScriptId();
+      document.setScriptID2URL(scriptID, source); // Sometimes we cannot catch the DOM access by a parent script in BindingSecurity
+      source.append("_-INSERTION-_");
+      source.append(String::Number(document.insertedScriptCount()));
+      loader_->setInsertingScriptURL(source);
+      setParentScriptID(String::Number(scriptID));
+      if (getInitiator().length() == 0)
+        setInitiator(String::Number(scriptID));
+    }
+  }
+}
 
 HTMLScriptElement* HTMLScriptElement::Create(
     Document& document,
@@ -77,11 +104,29 @@ void HTMLScriptElement::ChildrenChanged(const ChildrenChange& change) {
     loader_->ChildrenChanged();
 }
 
+
+const AtomicString HTMLScriptElement::initiator() {
+  AtomicString value = AtomicString(getInitiator());
+  setAttribute(HTMLNames::initiatorAttr, value);
+  return value;
+}
+  
+
+const AtomicString HTMLScriptElement::observerLog()
+{
+  AtomicString value = AtomicString(m_observerLogManager.getObserverLogs());
+  setAttribute(HTMLNames::observerlogAttr, value);
+  return value;
+}
+
+
+
 void HTMLScriptElement::DidMoveToNewDocument(Document& old_document) {
   ScriptRunner::MovePendingScript(old_document, GetDocument(), loader_.Get());
   HTMLElement::DidMoveToNewDocument(old_document);
 }
 
+
 void HTMLScriptElement::ParseAttribute(
     const AttributeModificationParams& params) {
   if (params.name == srcAttr) {
@@ -94,6 +139,30 @@ void HTMLScriptElement::ParseAttribute(
   }
 }
 
+void HTMLScriptElement::setChildrenInitiator(String initiator) {
+  setInitiator(initiator);
+  NodeList* children = childNodes();
+  int length = children->length();
+  for (int i = 0; i < length; ++i) {
+    Node* child = children->item(i);
+    if (child->IsElementNode()) {
+      if(IsHTMLAnchorElement(child)||IsHTMLScriptElement(child)) {
+        String childInitiator;
+        if(IsHTMLAnchorElement(child)) 
+          childInitiator = ToHTMLAnchorElement(child)->getInitiator();
+        else
+          childInitiator = ToHTMLScriptElement(child)->getInitiator();
+        if (childInitiator != initiator) {
+          if(IsHTMLAnchorElement(child)) 
+            ToHTMLAnchorElement(child)->setChildrenInitiator(initiator);
+          else
+            ToHTMLScriptElement(child)->setChildrenInitiator(initiator);
+        }
+      }
+    }
+  }
+}
+
 Node::InsertionNotificationRequest HTMLScriptElement::InsertedInto(
     ContainerNode* insertion_point) {
   ScriptType script_type = ScriptType::kClassic;
@@ -134,6 +203,33 @@ String HTMLScriptElement::SourceAttributeValue() const {
   return getAttribute(srcAttr).GetString();
 }
 
+const KURL HTMLScriptElement::parentSrc() const {
+  return GetDocument().CompleteURL(sourceInlineAttributeValue());
+}
+
+String HTMLScriptElement::sourceInlineAttributeValue() const {
+  return getAttribute(parentsrcAttr).GetString();
+}
+
+void HTMLScriptElement::setParentSrc(const String& source) {
+  setAttribute(parentsrcAttr, source.Utf8().data());
+}
+
+const AtomicString HTMLScriptElement::parentScriptID()
+{
+  AtomicString value = AtomicString(m_parentScriptID);
+  setAttribute(parentscriptidAttr, value);
+  return value;
+}
+
+const AtomicString HTMLScriptElement::scriptID()
+{
+  AtomicString value = AtomicString::Number(m_scriptID);
+  setAttribute(scriptidAttr, value);
+  return value;
+}
+
+
 String HTMLScriptElement::CharsetAttributeValue() const {
   return getAttribute(charsetAttr).GetString();
 }
diff --git a/core/html/HTMLScriptElement.h b/core/html/HTMLScriptElement.h
index 27d492e5..93d55031 100644
--- a/core/html/HTMLScriptElement.h
+++ b/core/html/HTMLScriptElement.h
@@ -48,17 +48,41 @@ class CORE_EXPORT HTMLScriptElement final : public HTMLElement,
 
   KURL Src() const;
 
+  const KURL parentSrc() const;
+  void setParentSrc(const String&);
+
+  const AtomicString parentScriptID();
+  String getParentScriptID() const { return m_parentScriptID; }
+  void setParentScriptID(const String& scriptID) { m_parentScriptID = scriptID; }
+
+  const AtomicString scriptID();
+  int getScriptID() const { return m_scriptID; }
+  void setScriptID(int scriptID) { m_scriptID = scriptID; }
+
+
   void setAsync(bool);
   bool async() const;
 
   ScriptLoader* Loader() const final { return loader_.Get(); }
 
+  bool IsHTMLScript() const override { return true; }
+
   bool IsScriptElement() const override { return true; }
   Document& GetDocument() const override;
 
   virtual void Trace(blink::Visitor*);
   void TraceWrappers(const ScriptWrappableVisitor*) const;
 
+  const AtomicString initiator() override;
+  String getInitiator() const { return initiator_; }
+  void setInitiator(String initiator) { initiator_ = initiator; }
+  void setChildrenInitiator(String initiator);
+
+  ObserverLogManager m_observerLogManager;
+  void appendObserverLog(const String& log) { m_observerLogManager.appendObserverLog(log); }
+  const AtomicString observerLog() override;
+
+
  private:
   HTMLScriptElement(Document&,
                     bool was_inserted_by_parser,
@@ -77,6 +101,7 @@ class CORE_EXPORT HTMLScriptElement final : public HTMLElement,
 
   // ScriptElementBase overrides:
   String SourceAttributeValue() const override;
+  String sourceInlineAttributeValue() const;
   String CharsetAttributeValue() const override;
   String TypeAttributeValue() const override;
   String LanguageAttributeValue() const override;
@@ -106,7 +131,11 @@ class CORE_EXPORT HTMLScriptElement final : public HTMLElement,
 
   Element* CloneElementWithoutAttributesAndChildren() override;
 
+  String m_parentScriptID;
+  int m_scriptID;
   TraceWrapperMember<ScriptLoader> loader_;
+  
+  String initiator_;
 };
 
 }  // namespace blink
diff --git a/core/html/HTMLScriptElement.idl b/core/html/HTMLScriptElement.idl
index 5a568bfe..c5198e1f 100644
--- a/core/html/HTMLScriptElement.idl
+++ b/core/html/HTMLScriptElement.idl
@@ -19,16 +19,23 @@
 
 // https://html.spec.whatwg.org/#the-script-element
 
-interface HTMLScriptElement : HTMLElement {
+[
+    CheckSecurity=Caller
+] interface HTMLScriptElement : HTMLElement {
     [CEReactions, Reflect, URL, RaisesException=Setter] attribute ScriptURLString src;
     [CEReactions, Reflect] attribute DOMString type;
     [CEReactions, Reflect] attribute boolean noModule;
     [CEReactions, Reflect] attribute DOMString charset;
     [CEReactions] attribute boolean async;
     [CEReactions, Reflect] attribute boolean defer;
+    [CEReactions, Reflect, URL, RaisesException=Setter] attribute ScriptURLString parentSrc;
     [CEReactions, Reflect, ReflectOnly=("anonymous","use-credentials"), ReflectEmpty="anonymous", ReflectInvalid="anonymous"] attribute DOMString? crossOrigin;
     [CEReactions] attribute DOMString text;
 
+    readonly attribute DOMString scriptID;
+    readonly attribute DOMString parentScriptID;
+    readonly attribute DOMString initiator;
+    readonly attribute DOMString observerLog;
     // obsolete members
     // https://html.spec.whatwg.org/#HTMLScriptElement-partial
     // TODO(foolip): The event and htmlFor attributes should return the empty
diff --git a/core/html/HTMLTimeElement.idl b/core/html/HTMLTimeElement.idl
index 48677ffe..95f3c1a6 100644
--- a/core/html/HTMLTimeElement.idl
+++ b/core/html/HTMLTimeElement.idl
@@ -4,7 +4,7 @@
 
 // https://html.spec.whatwg.org/multipage/text-level-semantics.html#the-time-element
 
-[HTMLConstructor]
+[HTMLConstructor] 
 interface HTMLTimeElement : HTMLElement {
     [CEReactions, Reflect] attribute DOMString dateTime;
-};
\ No newline at end of file
+};
diff --git a/core/html/parser/HTMLConstructionSite.cpp b/core/html/parser/HTMLConstructionSite.cpp
index a705f6bc..42048118 100644
--- a/core/html/parser/HTMLConstructionSite.cpp
+++ b/core/html/parser/HTMLConstructionSite.cpp
@@ -65,6 +65,11 @@
 #include "platform/bindings/V8PerIsolateData.h"
 #include "platform/text/TextBreakIterator.h"
 
+// Observer
+#include "base/logging.h"
+#include "core/dom/Observer.h"
+#include "bindings/core/v8/BindingSecurity.h"
+
 namespace blink {
 
 using namespace HTMLNames;
@@ -683,6 +688,11 @@ void HTMLConstructionSite::InsertHTMLFormElement(AtomicHTMLToken* token,
 
 void HTMLConstructionSite::InsertHTMLElement(AtomicHTMLToken* token) {
   Element* element = CreateElement(token, xhtmlNamespaceURI);
+  Document& document = OwnerDocumentForCurrentNode();
+  if (document.IsInDocumentWrite()) {
+    if(IsHTMLAnchorElement(element) || IsHTMLScriptElement(element))
+      BindingSecurity::SetNodeAndChildrenInitiator(&document, element, false);
+  }
   AttachLater(CurrentNode(), element);
   open_elements_.Push(HTMLStackItem::Create(element, token));
 }
@@ -693,7 +703,13 @@ void HTMLConstructionSite::InsertSelfClosingHTMLElementDestroyingToken(
   // Normally HTMLElementStack is responsible for calling finishParsingChildren,
   // but self-closing elements are never in the element stack so the stack
   // doesn't get a chance to tell them that we're done parsing their children.
-  AttachLater(CurrentNode(), CreateElement(token, xhtmlNamespaceURI), true);
+  Element* element = CreateElement(token, xhtmlNamespaceURI);
+  Document& document = OwnerDocumentForCurrentNode();
+  if (document.IsInDocumentWrite()) {
+    if(IsHTMLAnchorElement(element) || IsHTMLScriptElement(element))
+      BindingSecurity::SetNodeAndChildrenInitiator(&document, element, false);
+  }
+  AttachLater(CurrentNode(), element, true);
   // FIXME: Do we want to acknowledge the token's self-closing flag?
   // http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html#acknowledge-self-closing-flag
 }
@@ -728,6 +744,9 @@ void HTMLConstructionSite::InsertScriptElement(AtomicHTMLToken* token) {
   HTMLScriptElement* element =
       HTMLScriptElement::Create(OwnerDocumentForCurrentNode(), parser_inserted,
                                 already_started, created_during_document_write);
+  if (created_during_document_write) {
+    BindingSecurity::SetNodeAndChildrenInitiator(&OwnerDocumentForCurrentNode(), element, false);
+  }
   SetAttributes(element, token, parser_content_policy_);
   if (ScriptingContentIsAllowed(parser_content_policy_))
     AttachLater(CurrentNode(), element);
@@ -742,6 +761,11 @@ void HTMLConstructionSite::InsertForeignElement(
   DVLOG(1) << "Not implemented.";
 
   Element* element = CreateElement(token, namespace_uri);
+  Document& document = OwnerDocumentForCurrentNode();
+  if (document.IsInDocumentWrite()) {
+    if(IsHTMLAnchorElement(element) || IsHTMLScriptElement(element))
+      BindingSecurity::SetNodeAndChildrenInitiator(&document, element, false);
+  }
   if (ScriptingContentIsAllowed(parser_content_policy_) ||
       !element->IsScriptElement()) {
     AttachLater(CurrentNode(), element, token->SelfClosing());
diff --git a/core/svg/SVGElement.cpp b/core/svg/SVGElement.cpp
index 96818f4b..50f14b53 100644
--- a/core/svg/SVGElement.cpp
+++ b/core/svg/SVGElement.cpp
@@ -21,7 +21,6 @@
  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  * Boston, MA 02110-1301, USA.
  */
-
 #include "core/svg/SVGElement.h"
 
 #include "bindings/core/v8/ScriptEventListener.h"
@@ -57,8 +56,8 @@
 #include "platform/wtf/AutoReset.h"
 #include "platform/wtf/Threading.h"
 
-namespace blink {
 
+namespace blink {
 using namespace HTMLNames;
 using namespace SVGNames;
 
diff --git a/core/svg/SVGScriptElement.h b/core/svg/SVGScriptElement.h
index a1c420a5..26deb401 100644
--- a/core/svg/SVGScriptElement.h
+++ b/core/svg/SVGScriptElement.h
@@ -42,6 +42,8 @@ class SVGScriptElement final : public SVGElement,
 
   ScriptLoader* Loader() const final { return loader_.Get(); }
 
+  bool IsHTMLScript() const override { return false; }
+
 #if DCHECK_IS_ON()
   bool IsAnimatableAttribute(const QualifiedName&) const override;
 #endif
